Level 3 코딩테스트 연습

목표
> Level 3 & 4  
> Visual Studio 2019 사용  


### 목차
- 힙
  - [1. 디스크 컨트롤러](#1-디스크-컨트롤러)
- 동적계획법
  - [1. 정수 삼각형](#1-정수-삼각형)  
  - [2. 등굣길](#2-등굣길)  
- 깊이/너비 우선 탐색
  - [1. 네트워크](#1-네트워크)
- 그래프
  - [1. 순위](#1-순위)  
- 기타
  - [1. 추석 트래픽](#1-추석-트래픽)
  - [2. 보석 쇼핑](#2-보석-쇼핑)
<br>

# 문제
### 힙 Heap
## 1. 디스크 컨트롤러
하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다. 디스크 컨트롤러를 구현하는 방법은 여러 가지가 있습니다. 가장 일반적인 방법은 요청이 들어온 순서대로 처리하는 것입니다.  
예를 들어
  + *0ms 시점에 3ms가 소요되는 A작업 요청*  
  + *1ms 시점에 9ms가 소요되는 B작업 요청*  
  + *2ms 시점에 6ms가 소요되는 C작업 요청*  

와 같은 요청이 들어왔습니다. 이를 그림으로 표현하면 아래와 같습니다.  
<img src="https://user-images.githubusercontent.com/39071652/126661333-eb9f5d1c-d850-459e-b246-2208ee4ac0ba.png" width="500">  
한 번에 하나의 요청만을 수행할 수 있기 때문에 각각의 작업을 요청받은 순서대로 처리하면 다음과 같이 처리 됩니다.  
<img src="https://user-images.githubusercontent.com/39071652/126743294-268dc891-014c-4731-89e4-76076354d133.png" width="500">  
  + *A: 3ms 시점에 작업 완료 (요청에서 종료까지 : 3ms)*  
  + *B: 1ms부터 대기하다가, 3ms 시점에 작업을 시작해서 12ms 시점에 작업 완료(요청에서 종료까지 : 11ms)*  
  + *C: 2sm부터 대가하다가, 12ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 16ms)*  

이 때 각 작업의 요청부터 종료까지 걸리 시간의 평균은 10ms(=(3 + 11 + 16) / 3)가 됩니다.  
하지만 A->C->B 순서대로 처리하면  
<img src="https://user-images.githubusercontent.com/39071652/126743361-d7f012e6-2edc-4370-aa30-700875368dd0.png" width="500">  
  + *A: 3ms 시점에 작업 완료(요청에서 종료까지 : 3ms)*  
  + *C: 2ms부터 대기하다가, 3ms 시점에 작업을 시작해서 9ms 시점에 작업 완료(요청에서 종료까지 : 7ms)*  
  + *B: 1ms부터 대기하다가, 9ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 17ms)*  

이렇게 A->C->B의 순서로 처리하면 각 작업의 요청부터 종료까지 걸리 시간의 평균은 9ms(=(3 + 7 + 17) / 3)가 됩니다.  
각 작업에 대해 [작업이 요청되는 시점, 작업의 소요시간]을 담은 2차원 배열 jobs가 매개변수로 주어질 때, 작업의 요청부터 종료까지 걸린 시간의 평균을 가장 줄이는 방법으로 처리하면 평균이 얼마가 되는지 return 하도록 solution 함수를 작성해주세요. (단, 소수점 이하의 수는 버립니다)  

###### 제한 사항
  + jobs의 길이는 1 이상 500 이하입니다.
  + jobs의 각 행은 하나의 작업에 대한 [작업이 요청되는 시점, 작업의 소요시간] 입니다.
  + 각 작업에 대해 작업이 요청되는 시간은 0 이상 1,000 이하입니다.
  + 각 작업에 대해 작업의 소요시간은 1 이상 1,000 이하입니다.
  + 하드디스크가 작업을 수행하고 있지 않을 때에는 먼저 요청이 들어온 작업부터 처리합니다.

###### 입출력 예
|jobs|return|
|:---|:---|
|[[0,3],[1,9],[2,6]]|9|

###### 입출력 예 설명
문제에 주어진 예와 같습니다.  
  + 0ms 시점에 3ms 걸리는 작업 요청이 들어옵니다.
  + 1ms 시점에 9ms 걸리는 작업 요청이 들어옵니다.
  + 2ms 시점에 6ms 걸리는 작업 요청이 들어옵니다.

###### 코드 : [Disk_Controller.cpp](./Disk_Controller.cpp)
<br>

### 동적계획법(Dynamic Programming); DP
## 1. 정수 삼각형
<img src="https://user-images.githubusercontent.com/39071652/126117081-5a8a14bf-da2b-476c-b331-a9f299efa0ae.png" width="200">  
위와 같은 삼각형의 꼭대기에서 바닥까지 이어지는 경로 중, 거쳐간 숫자의 합이 가장 큰 경우를 찾아보려고 합니다. 아래 칸으로 이동할 때는 대각선 방향으로 한 칸 오른쪽 또는 왼쪽으로만 이동 가능합니다. 예를 들어 3에서는 그 아래칸의 8 또는 1로만 이동이 가능합니다. 삼각형의 정보가 담긴 배열 triangle이 매개변수로 주어질 때, 거쳐간 숫자의 최댓값을 return 하도록 solution 함수를 완성하세요.  

###### 제한사항
  + 삼각형의 높이는 1 이상 500 이하입니다.  
  + 삼각형을 이루고 있는 숫자는 0 이상 9,999 이하의 정수입니다.  

###### 입출력 예
|triangle|result| 
|:---|:---|
|[[7],[3,8],[8,1,0],[2,7,4,4],[4,5,2,6,5]]|30|

###### 코드 : [Integer_Triangle.cpp](./Integer_Triangle.cpp)  
<br>

## 2. 등굣길  
계속되는 폭우로 일부 지역이 물에 잠겼습니다. 물에 잠기지 않은 지역을 통해 학교를 가려고 합니다. 집에서 학교까지 가는 길은 m x n 크기의 격자모양으로 나타낼 수 있습니다. 아래 그림은 m=4, n=3 인 경우입니다.  
<img src="https://user-images.githubusercontent.com/39071652/126125590-a724b84c-6551-4269-b27d-ac04dc1d6c97.png" width="200">  
가장 왼쪽 위, 즉 집이 있는 곳의 좌표는 (1,1)로 나타내고 가장 오른쪽 아래, 즉 학교가 있는 곳의 좌표는 (m,n)으로 나타냅니다.  
격자의 크기 m, n과 물이 잠긴 지역의 좌표를 담은 2차원 배열 puddles이 매개변수로 주어집니다. **오른쪽과 아래쪽으로만 움직여** 집에서 학교까지 갈 수 있는 최단경로의 개수를 1,000,000,007로 나눈 나머지를 return 하도록 solution 함수를 작성해주세요.  

###### 제한사항
  + 격자의 크기 m, n은 1 이상 100 이하인 자연수입니다.
    - m과 n이 모두 1인 경우는 입력으로 주어지지 않습니다.
  + 물에 잠긴 지역은 0개 이상 10개 이하입니다.
  + 집과 학교가 물에 잠긴 경우는 입력으로 주어지지 않습니다.

###### 입출력 예
|m|n|puddles|result|
|:---|:---|:---|:---|
|4|3|[[2,2]]|4|

###### 입출력 예 설명
<img src="https://user-images.githubusercontent.com/39071652/126125781-02ad7346-c16c-4f82-be6c-9384eed6d9fb.png" width="200">  

###### 코드 : [Way_to_School.cpp](./Way_to_School.cpp)
<br>

### 깊이/너비 우선 탐색(Depth/Breadth First Search); DFS/BFS
## 1. 네트워크
네트워크란 컴퓨터 상호 간에 정보를 교환할 수 있도록 연결된 형태를 의미합니다. 예를 들어, 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다. 따라서 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다. 컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오.  

###### 제한사항
  + 컴퓨터의 개수 n은 1 이상 200 이하인 자연수입니다.
  + 각 컴퓨터는 0부터 *n-1*인 정수로 표현합니다.
  + i번 컴퓨터와 j번 컴퓨터가 연결되어 있으면 computers[i][j]를 1로 표현합니다.
  + computers[i][i]는 항상 1입니다.

###### 입출력 예
|n|computers|return|
|:---|:---|:---|
|3|[[1,1,0],[1,1,0],[0,0,1]]|2|
|3|[[1,1,0],[1,1,1],[0,1,1]]|1|

###### 입출력 예 설명
<img src="https://user-images.githubusercontent.com/39071652/126175476-c3261948-49cf-4b67-a9ec-91e017040e6a.png" width="200"> <img src="https://user-images.githubusercontent.com/39071652/126175589-0c6a1f4e-31fb-4831-a595-e8d26a59519d.png" width="200">  
(왼쪽 그림 : 네트워크 2개 / 오른쪽 그림 : 네트워크 1개)

###### 코드 : [Network.cpp](./Network.cpp)
<br>

### 그래프 Graph
## 1. 순위
n명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.  
선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때 정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요.  

###### 제한사항
  + 선수의 수는 1명 이상 100명 이하입니다.
  + 경기 결과는 1개 이상 4,500개 이하입니다.
  + results 배열 각 행 [A,B]는 A선수가 B선수를 이겼다는 의미입니다.
  + 모든 경기 결과에는 모순이 없습니다.

###### 입출력 예
|n|results|return|
|:---|:---|:---|
|5|[[4,3],[4,2],[3,2],[1,2],[2,5]]|2|

###### 입출력 예 설명
2번 선수는 [1,3,4] 선수에게 패배했고 5번 선수에게 승리했기 때문에 4위입니다.  
5번 선수는 4위인 2번 선수에게 패배했기 때문에 5위입니다.

###### 코드 : [Rank.cpp](./Rank.cpp)
<br>

### 기타
###### 2018 KAKAO BLIND RECRUITMENT
## 1. 추석 트래픽
이번 추석에도 시스템 장애가 없는 명절을 보내고 싶은 어피치는 서버를 증설해야 할지 고민이다. 장애 대비용 서버 증설 여부를 결정하기 위해 작년 추석 기간인 9월 15일 로그 데이터를 분석한 후 초당 최대 처리량을 계산해보기로 했다. **초당 최대 처리량**은 요청의 응답 완료 여부에 관계없이 임의 시간부터 1초(=1,000밀리초)간 처리하는 요청의 최대 개수를 의미한다.

###### 입력 형식
  + *solution* 함수에 전달되는 lines 배열은 **N**(1≤**N**≤2,000)개의 로그 문자열로 되어 있으며, 각 로그 문자열마다 요청에 대한 응답완료시간 **S**와 처리시간 **T**가 공백으로 구분되어 있다.
  + 응답완료시간 **S**는 작년 추석인 2016년 9월 15일만 포함하여 고정 길이 *2016-09-15 hh:mm:ss.sss* 형식으로 되어 있다.
  + 처리시간 **T**는 *0.1s*, *0.312s*, *2s*와 같이 최대 소수점 셋째 자리까지 기록하며 뒤에는 초 단위를 의미하는 *s*로 끝난다.
  + 예를 들어, 로그 문자열 *2016-09-15 03:10:33.020 0.011s*은 "2016년 9월 15일 오전 3시 10분 **33.010초**"부터 "2016년 9월 15일 오전 3시 10분 **33.020초**까지 "**0.011초**" 동안 처리된 요청을 의미한다. **(처리시간은 시작시간과 끝시간을 포함)**
  + 서버에는 타임아웃이 3초로 적용되어 있기 때문에 처리시간은 **0.001≤T≤3.000**이다.
  + *lines* 배열은 응답완료시간 **S**를 기준으로 오름차순 정렬되어 있따.

###### 출력 형식
  + *solution* 함수에서는 로그 데이터 *lines* 배열에 대해 **초당 최대 처리량**을 리턴한다.

###### 입출력 예제
###### 예제1
  + 입력: ["2016-09-15 01:00:04.001 2.0s", "2016-09-15 01:00:07.000 2s"]
  + 출력: 1

###### 예제2
  + 입력: ["2016-09-15 01:00:04.002 2.0s","2016-09-15 01:00:07.000 2s"]
  + 출력: 2
  + 설명: 처리시간은 시작시간과 끝시간을 **포함**하므로 첫 번째 로그는 *01:00:02.003 ~ 01:00:04.002*에서 2초동안 처리되었으며, 두 번째 로그는 *01:00:05.001 ~ 01:00:07:000*에서 2초동안 처리된다. 따라서, 첫 번째 로그가 끝나는 시점과 두 번째 로그가 시작하는 시점의 구간인 *01:00:04.002 ~ 01:00:05.001* 1초동안 최대 2개가 된다.

###### 예제3
  + 입력: ["2016-09-15 20:59:57.421 0.351s","2016-09-15 20:59:58.233 1.181s","2016-09-15 20:59:58.299 0.8s","2016-09-15 20:59:58.688 1.041s","2016-09-15 20:59:59.591 1.412s","2016-09-15 21:00:00.464 1.466s","2016-09-15 21:00:00.741 1.581s","2016-09-15 21:00:00.748 2.31s","2016-09-15 21:00:00.966 0.381s","2016-09-15 21:00:02.066 2.62s"]
  + 출력: 7
  + 설명: 아래 타임라인 그림에서 빨간색으로 표시된 1초 각 구간의 처리량을 구해보면 (1)은 4개, (2)는 7개, (3)는 2개임을 알 수 있다. 따라서 **초당 최대 처리량**은 7이 되며, 최대 처리량을 갖는 1초 구간은 여러 개 존재할 수 있으므로 이 문제에서는 구간이 아닌 개수만 출력한다.
<img src="https://user-images.githubusercontent.com/39071652/126509678-7a06cf02-e342-455c-87ab-7e31fb4872ea.png" width="400"> 

###### 코드 : [Chuseok_Traffic.cpp](./Chuseok_Traffic.cpp)
<br>

###### 2020 카카오 인턴십
## 2. 보석 쇼핑
개발자 출신으로 세계 최고의 갑부가 된 어피치는 스트레스를 받을 때면 이를 풀기 위해 오프라인 매장에 쇼핑을 하러 가곤 합니다. 어피치는 쇼핑을 할 때면 매장 진열대의 특정 범위의 물건들을 모두 싹쓸이 구매하는 습관이 있습니다.  
어느 날 스트레스를 풀기 위해 보석 매장에 쇼핑을 하러 간 어피치는 이전처럼 진열대의 특정 범위의 보석을 모두 구매하되 특별히 아래 목적을 달성하고 싶었습니다.  
**진열된 모든 종류의 보석을 적어도 1개 이상 포함하는 가장 짧은 구간을 찾아서 구매**  
예를 들어 아래 진열대는 4종류의 보석(RUBY, DIA, EMERALD, SAPPHIRE) 8개가 진열된 예시입니다.  

|진열대 번호|1|2|3|4|5|6|7|8|
|:---|:---|:---|:---|:---|:---|:---|:---|
|보석이름|DIA|RUBY|*RUBY*|*DIA*|*DIA*|*EMERALD*|*SAPPHIRE*|DIA|

진열대의 3번부터 7번까지 5개의 보석을 구매하면 모든 종류의 보석을 적어도 하나 이상씩 포함하게 됩니다.  
진열대의 3, 4, 6, 7번의 보석만 구매하는 것은 중간에 특정 구간(5번)이 빠지게 되므로 어피치의 쇼핑 습관에 맞지 않습니다.  
진열대 번호 순서대로 보석들의 이름이 저장된 배열 gems가 매개변수로 주어집니다. 이때 모든 보석을 하나 이상 포함하는 가장 짧은 구간을 찾아서 return 하도록 solution 함수를 완성해주세요.  
가장 짧은 구간의 **시간 진열대 번호**와 **끝 진열대 번호**를 차례대로 배열에 담아서 return 하도록 하며, 만약 가장 짧은 구간이 여러 개라면 **시작 진열대 번호**가 가장 작은 구간을 return 합니다.

###### 제한사항
  + gems 배열의 크기는 1 이상 100,000 이하입니다.
    - gems 배열의 각 원소는 진열대에 나열된 보석을 나타냅니다.
    - gems 배열에는 1번 진열대부터 진열대 번호 순서대로 보석이름이 차례대로 저장되어 있습니다.
    - gems 배열의 각 원소에는 길이가 1 이상 10 이하인 알파벳 대문자로만 구성된 문자열입니다.

###### 입출력 예
|gems|result|
|:---|:---|
|["DIA", "RUBY", "RUBY", "DIA", "DIA", "EMERALD", "SAPPHIRE", "DIA"]|[3, 7]|
|["AA", "AB", "AC", "AA", "AC"]|[1, 3]|
|["XYZ", "XYZ", "XYZ"]|[1, 1]|
|["ZZZ", "YYY", "NNNN", "YYY", "BBB"]|[1, 5]|

###### 입출력 예에 대한 설명
입출력 예 #1  
문제 예시와 같습니다.  

입출력 예 #2  
3종류의 보석(AA, AB, AC)을 모두 포함하는 가장 짧은 구간은 [1, 3], [2, 4]가 있습니다. **시작 진열대 번호**가 더 작은 [1, 3]을 return 해주어야 합니다.  

입출력 예 #3  
1종류의 보석(XYZ)을 포함하는 가장 짧은 구간은 [1, 1], [2, 2], [3, 3]이 있습니다. **시작 진열대 번호**가 가장 작은 [1, 1]을 return 해주어야 합니다.  

입출력 예 #4  
4종류의 보석(ZZZ, YYY, NNNN, BBB)을 모두 포함하는 구간은 [1, 5]가 유일합니다. 그러므로 [1, 5]를 return 해주어야 합니다.  

###### 코드 : [Jewelry_Shopping.cpp](./Jewelry_Shopping.cpp)
<br>

--------
<br>

##### 문제출처 및 이용 사이트
> 프로그래머스 [Programmers](https://programmers.co.kr)  

##### 사용 프로그램
> Visual Studio 2019  
