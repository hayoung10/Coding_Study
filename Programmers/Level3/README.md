Level 3 코딩테스트 연습

목표
> Level 3 & 4  
> Visual Studio 2019 사용  


### 목차
- 힙
  - [1. 디스크 컨트롤러](#1-디스크-컨트롤러)
- 동적계획법
  - [1. 정수 삼각형](#1-정수-삼각형)  
  - [2. 등굣길](#2-등굣길)  
  - [3. GPS](#3-gps)
  - [4. 스티커 모으기](#4-스티커-모으기)
- 깊이/너비 우선 탐색
  - [1. 네트워크](#1-네트워크)
  - [2. 불량 사용자](#2-불량-사용자)
  - [3. 여행경로](#3-여행경로)
  - [4. 다단계 칫솔 판매](#4-다단계-칫솔-판매)
  - [5. 경주로 건설](#5-경주로-건설)
  - [6. 블록 이동하기](#6-블록-이동하기)
  - [7. 퍼즐 조각 채우기](#7-퍼즐-조각-채우기)
  - [8. 모두 0으로 만들기](#8-모두-0으로-만들기)
- 그래프
  - [1. 순위](#1-순위)
  - [2. 가장 먼 노드](#2-가장-먼-노드)  
- 이분탐색
  - [1. 입국심사](#1-입국심사)
  - [2. 징검다리 건너기](#2-징검다리-건너기)
- 탐욕법
  - [1. 단속카메라](#1-단속카메라)
- 트리
  - [1. 길 찾기 게임](#1-길-찾기-게임)
- 기타
  - [1. 추석 트래픽](#1-추석-트래픽)
  - [2. 보석 쇼핑](#2-보석-쇼핑)
  - [3. 자물쇠와 열쇠](#3-자물쇠와-열쇠)
  - [4. 표 편집](#4-표-편집)
  - [5. 기지국 설치](#5-기지국-설치)
  - [6. 가장 긴 팰린드롬](#6-가장-긴-팰린드롬)
  - [7. 숫자 게임](#7-숫자-게임)
  - [8. 최고의 집합](#8-최고의-집합)
<br>

# 문제
### 힙 Heap
## 1. 디스크 컨트롤러
하드디스크는 한 번에 하나의 작업만 수행할 수 있습니다. 디스크 컨트롤러를 구현하는 방법은 여러 가지가 있습니다. 가장 일반적인 방법은 요청이 들어온 순서대로 처리하는 것입니다.  
예를 들어
  + *0ms 시점에 3ms가 소요되는 A작업 요청*  
  + *1ms 시점에 9ms가 소요되는 B작업 요청*  
  + *2ms 시점에 6ms가 소요되는 C작업 요청*  

와 같은 요청이 들어왔습니다. 이를 그림으로 표현하면 아래와 같습니다.  
<img src="https://user-images.githubusercontent.com/39071652/126661333-eb9f5d1c-d850-459e-b246-2208ee4ac0ba.png" width="500">  
한 번에 하나의 요청만을 수행할 수 있기 때문에 각각의 작업을 요청받은 순서대로 처리하면 다음과 같이 처리 됩니다.  
<img src="https://user-images.githubusercontent.com/39071652/126743294-268dc891-014c-4731-89e4-76076354d133.png" width="500">  
  + *A: 3ms 시점에 작업 완료 (요청에서 종료까지 : 3ms)*  
  + *B: 1ms부터 대기하다가, 3ms 시점에 작업을 시작해서 12ms 시점에 작업 완료(요청에서 종료까지 : 11ms)*  
  + *C: 2sm부터 대가하다가, 12ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 16ms)*  

이 때 각 작업의 요청부터 종료까지 걸리 시간의 평균은 10ms(=(3 + 11 + 16) / 3)가 됩니다.  
하지만 A->C->B 순서대로 처리하면  
<img src="https://user-images.githubusercontent.com/39071652/126743361-d7f012e6-2edc-4370-aa30-700875368dd0.png" width="500">  
  + *A: 3ms 시점에 작업 완료(요청에서 종료까지 : 3ms)*  
  + *C: 2ms부터 대기하다가, 3ms 시점에 작업을 시작해서 9ms 시점에 작업 완료(요청에서 종료까지 : 7ms)*  
  + *B: 1ms부터 대기하다가, 9ms 시점에 작업을 시작해서 18ms 시점에 작업 완료(요청에서 종료까지 : 17ms)*  

이렇게 A->C->B의 순서로 처리하면 각 작업의 요청부터 종료까지 걸리 시간의 평균은 9ms(=(3 + 7 + 17) / 3)가 됩니다.  
각 작업에 대해 [작업이 요청되는 시점, 작업의 소요시간]을 담은 2차원 배열 jobs가 매개변수로 주어질 때, 작업의 요청부터 종료까지 걸린 시간의 평균을 가장 줄이는 방법으로 처리하면 평균이 얼마가 되는지 return 하도록 solution 함수를 작성해주세요. (단, 소수점 이하의 수는 버립니다)  

###### 제한 사항
  + jobs의 길이는 1 이상 500 이하입니다.
  + jobs의 각 행은 하나의 작업에 대한 [작업이 요청되는 시점, 작업의 소요시간] 입니다.
  + 각 작업에 대해 작업이 요청되는 시간은 0 이상 1,000 이하입니다.
  + 각 작업에 대해 작업의 소요시간은 1 이상 1,000 이하입니다.
  + 하드디스크가 작업을 수행하고 있지 않을 때에는 먼저 요청이 들어온 작업부터 처리합니다.

###### 입출력 예
|jobs|return|
|:---|:---|
|[[0,3],[1,9],[2,6]]|9|

###### 입출력 예 설명
문제에 주어진 예와 같습니다.  
  + 0ms 시점에 3ms 걸리는 작업 요청이 들어옵니다.
  + 1ms 시점에 9ms 걸리는 작업 요청이 들어옵니다.
  + 2ms 시점에 6ms 걸리는 작업 요청이 들어옵니다.

###### 코드 : [Disk_Controller.cpp](./Disk_Controller.cpp)
<br>

### 동적계획법(Dynamic Programming); DP
## 1. 정수 삼각형
<img src="https://user-images.githubusercontent.com/39071652/126117081-5a8a14bf-da2b-476c-b331-a9f299efa0ae.png" width="200">  
위와 같은 삼각형의 꼭대기에서 바닥까지 이어지는 경로 중, 거쳐간 숫자의 합이 가장 큰 경우를 찾아보려고 합니다. 아래 칸으로 이동할 때는 대각선 방향으로 한 칸 오른쪽 또는 왼쪽으로만 이동 가능합니다. 예를 들어 3에서는 그 아래칸의 8 또는 1로만 이동이 가능합니다. 삼각형의 정보가 담긴 배열 triangle이 매개변수로 주어질 때, 거쳐간 숫자의 최댓값을 return 하도록 solution 함수를 완성하세요.  

###### 제한사항
  + 삼각형의 높이는 1 이상 500 이하입니다.  
  + 삼각형을 이루고 있는 숫자는 0 이상 9,999 이하의 정수입니다.  

###### 입출력 예
|triangle|result| 
|:---|:---|
|[[7],[3,8],[8,1,0],[2,7,4,4],[4,5,2,6,5]]|30|

###### 코드 : [Integer_Triangle.cpp](./Integer_Triangle.cpp)  
<br>

## 2. 등굣길  
계속되는 폭우로 일부 지역이 물에 잠겼습니다. 물에 잠기지 않은 지역을 통해 학교를 가려고 합니다. 집에서 학교까지 가는 길은 m x n 크기의 격자모양으로 나타낼 수 있습니다. 아래 그림은 m=4, n=3 인 경우입니다.  
<img src="https://user-images.githubusercontent.com/39071652/126125590-a724b84c-6551-4269-b27d-ac04dc1d6c97.png" width="200">  
가장 왼쪽 위, 즉 집이 있는 곳의 좌표는 (1,1)로 나타내고 가장 오른쪽 아래, 즉 학교가 있는 곳의 좌표는 (m,n)으로 나타냅니다.  
격자의 크기 m, n과 물이 잠긴 지역의 좌표를 담은 2차원 배열 puddles이 매개변수로 주어집니다. **오른쪽과 아래쪽으로만 움직여** 집에서 학교까지 갈 수 있는 최단경로의 개수를 1,000,000,007로 나눈 나머지를 return 하도록 solution 함수를 작성해주세요.  

###### 제한사항
  + 격자의 크기 m, n은 1 이상 100 이하인 자연수입니다.
    - m과 n이 모두 1인 경우는 입력으로 주어지지 않습니다.
  + 물에 잠긴 지역은 0개 이상 10개 이하입니다.
  + 집과 학교가 물에 잠긴 경우는 입력으로 주어지지 않습니다.

###### 입출력 예
|m|n|puddles|result|
|:---|:---|:---|:---|
|4|3|[[2,2]]|4|

###### 입출력 예 설명
<img src="https://user-images.githubusercontent.com/39071652/126125781-02ad7346-c16c-4f82-be6c-9384eed6d9fb.png" width="200">  

###### 코드 : [Way_to_School.cpp](./Way_to_School.cpp)
<br>

###### 2017 카카오코드 본선
## 3. GPS
카카오 택시 개발자 Jay-G는 다음 업데이트를 준비하기 위해 개선사항을 위한 여러 피드백을 받았다. 그중에서 손님이 자주 탑승하는 위치를 추천해주었으면 한다는 의견이 많았다.  
다음 업데이트 준비를 위해 Jay-G는 택시의 승하차 및 이동 경로를 수집하여 분석하기 시작하였다. 데이터를 분석하던 Jay-G는 몇 가지 특이사항을 발견했다. 택시의 이동 경로를 GPS를 통해 수집하게 되는데, GPS 신호 불량, 통신 오류 등 다양한 원인으로 위치의 오류가 발생한 것을 알게 되었다. 다만 승차 위치와 하차 위치는 오류가 없는 것으로 확인이 되었다.  
개발자 Jay-G는 수집한 이동 경로의 오류를 최소한으로 수정하여 좀 더 정확한 이동 경로를 구하고 싶어 한다.  
택시는 다음과 같은 조건으로만 이동한다. 먼저 택시는 거점을 이동해 다니며, 거점 간의 이동은 해당하는 도로가 있는 경우에만 가능하다. 또한, 교통 상황에 따라 택시는 한 거점에 머무를 수 있고, 왔던 길을 되돌아갈 수 있다. 모든 도로는 방향이 별도로 없는 왕복 도로이다.  
<img src="https://user-images.githubusercontent.com/39071652/130805983-241764ee-c4b9-4059-9c3a-2172c6747abe.png" width="250">  
예를 들어, 위 그래프에서 택시가 다음과 같이 시간대별로 이동 경로를 보내왔다.  
|t|위치|
|:---|:---|
|1|1|
|2|2|
|3|3|
|4|3|
|5|6|
|6|7|

하지만 위의 택시가 보내온 경로에는 **거점 3**에서 **거점 6**으로 이동할 수 있는 도로가 없으므로 이동 경로에 오류가 있다.  
<img src="https://user-images.githubusercontent.com/39071652/130806233-92dae493-bd27-4e64-9f10-8052af734edf.png" width="250">  
이러한 오류를 최소한으로 수정하여 이동 가능한 경로로 만들고 싶다. 이 경우 1회의 오류를 수정하여 다음과 같이 이동 가능한 경로를 만들 수 있다. 시간 **t=4**의 위치를 **거점 5**로 한 번 수정하면 이동 가능한 경로가 된다.  
|t|위치|
|:---|:---|
|1|1|
|2|2|
|3|3|
|**4**|**5**|
|5|6|
|6|7|

<img src="https://user-images.githubusercontent.com/39071652/130806426-15605c0c-d9eb-4cc8-9847-717e0aaa42cc.png" width="250">  

이와 비슷하게 시간 **t=4**의 위치를 **거점 4**로 바꾸거나, 시간 **t=5** 위치를 **거점 5**로 바꾸면 이동 가능한 경로로 만들 수 있다. 위의 경우 수정한 오류의 개수는 1개이다.  

|t|위치|
|:---|:---|
|1|1|
|2|2|
|3|3|
|**4**|**4**|
|5|6|
|6|7|

|t|위치|
|:---|:---|
|1|1|
|2|2|
|3|3|
|4|3|
|**5**|**5**|
|6|7|

위와 같이 택시가 보내온 경로에서 이동 가능한 경로로 만드는 최소의 오류 수정 횟수를 구하여라.  

###### 입력 형식
주어지는 입력은 총 다섯 가지로, 거점 개수 **n**과 도로의 개수 **m**, 각 거점 간의 연결된 도로 정보 **edge_list**, 택시가 시간대별로 보내오는 거점 정보의 총 개수 **k**, 그리고 머물렀던 거점의 정보 **gps_log**이다. 제한조건은 아래와 같다.  
  - **2 ≤ n ≤ 200**
  - **1 ≤ m ≤ 10,000**
  - **2 ≤ k ≤ 100**
  - **edge_list**는 **m x 2** 크기의 2차원 배열로, 각 행의 두 값은 도로가 잇는 두 거점의 번호를 의미한다.
  - 거점의 번호는 1부터 n까지 숫자이다.
  - 모든 도로는 양방향 통행이 가능하다.
  - 입력되는 데이터에서 항상 모든 거점 간 경로가 있음이 보장되지 않는다.
  - **gps_log**의 시작 거점과 도착 거점은 바뀔 수 없다.

###### 출력 형식
이동 가능한 경로로 만들 수 있는 최소의 오류 수정 횟수를 리턴한다. 올바른 경로로 수정하는 것이 불가능할 경우 **-1**을 리턴한다.  

###### 예제 입출력
|변수명|값|
|:---|:---|
|n|7|
|m|10|
|edge_list|[[1, 2], [1, 3], [2, 3], [2, 4], [3, 4], [3, 5], [4, 6], [5, 6], [5, 7], [6, 7]]|
|k|6|
|gps_log|[1, 2, 3, 3, 6, 7]|
|answer|1|

|변수명|값|
|:---|:---|
|n|7|
|m|10|
|edge_list|[[1, 2], [1, 3], [2, 3], [2, 4], [3, 4], [3, 5], [4, 6], [5, 6], [5, 7], [6, 7]]|
|k|6|
|gps_log|[1, 2, 4, 6, 5, 7]|
|answer|0|

###### 예제에 대한 설명
두 예제 모두 **edge_list**의 데이터는 본문의 그림과 같은 예이다.  
첫 번째 테스트 케이스에서 **gps_log**로 주어진 경로 중 **거점 3**에서 **거점 6**으로 가는 도로가 없다. 여기서 시간 **t=4**의 위치를 **거점 5**로 한 번 수정하면 이동 가능한 경로가 된다.  
두 번째 테스트 케이스는 **gps_log**로 주어진 경로가 모두 도로로 연결된 경우이므로 수정이 필요 없다.

###### 코드 : [GPS.cpp](./GPS.cpp)
<br>

## 4. 스티커 모으기
N개의 스티커가 원형으로 연결되어 있습니다. 다음 그림은 N = 8인 경우의 예시입니다.  
<img src="https://user-images.githubusercontent.com/39071652/136966805-2b29933f-dc40-4aee-90e0-10c6e1f2cb35.PNG" width="200">  
원형으로 연결된 스티커에서 몇 장의 스티커를 뜯어내어 뜯어낸 스티커에 적힌 숫자의 합이 최대가 되도록 하고 싶습니다. 단 스티커 한 장을 뜯어내면 양쪽으로 인접해있는 스티커는 찢어져서 사용할 수 없게 됩니다.  
예를 들어 위 그림에서 14가 적힌 스티커를 뜯으면 인접해있는 10, 6이 적힌 스티커는 사용할 수 없습니다. 스티커에 적힌 숫자가 배열 형태로 주어질 때, 스티커를 뜯어내어 얻을 수 있는 숫자의 합의 최댓값을 return 하는 solution 함수를 완성해 주세요. 원형의 스티커 모양을 위해 배열의 첫 번째 원소와 마지막 원소가 서로 연결되어 있다고 간주합니다.  

###### 제한 사항
  - sticker는 원형으로 연결된 스티커의 각 칸에 적힌 숫자가 순서대로 들어있는 배열로, 길이(N)는 1 이상 100,000 이하입니다.
  - sticker의 각 원소는 스티커의 각 칸에 적힌 숫자이며, 각 칸에 적힌 숫자는 1 이상 100 이하의 자연수입니다.
  - 원형의 스티커 모양을 위해 sticker 배열의 첫 번째 원소와 마지막 원소가 서로 연결되어있다고 간주합니다.

###### 입출력 예
|sticker|answer|
|:---|:---|
|[14,6,5,11,3,9,2,10]|36|
|[1,3,2,5,4]|8|

###### 입출력 예 설명
입출력 예 #1  
6,11,9,10이 적힌 스티커를 떼어 냈을 때 36으로 최대가 됩니다.  

입출력 예 #2  
3,5가 적힌 스티커를 떼어 냈을 때 8로 최대가 됩니다.  

###### 코드 : [Collect_Stickers.cpp](./Collect_Stickers.cpp)

### 깊이/너비 우선 탐색(Depth/Breadth First Search); DFS/BFS
## 1. 네트워크
네트워크란 컴퓨터 상호 간에 정보를 교환할 수 있도록 연결된 형태를 의미합니다. 예를 들어, 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다. 따라서 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다. 컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오.  

###### 제한사항
  + 컴퓨터의 개수 n은 1 이상 200 이하인 자연수입니다.
  + 각 컴퓨터는 0부터 *n-1*인 정수로 표현합니다.
  + i번 컴퓨터와 j번 컴퓨터가 연결되어 있으면 computers[i][j]를 1로 표현합니다.
  + computers[i][i]는 항상 1입니다.

###### 입출력 예
|n|computers|return|
|:---|:---|:---|
|3|[[1,1,0],[1,1,0],[0,0,1]]|2|
|3|[[1,1,0],[1,1,1],[0,1,1]]|1|

###### 입출력 예 설명
<img src="https://user-images.githubusercontent.com/39071652/126175476-c3261948-49cf-4b67-a9ec-91e017040e6a.png" width="200"> <img src="https://user-images.githubusercontent.com/39071652/126175589-0c6a1f4e-31fb-4831-a595-e8d26a59519d.png" width="200">  
(왼쪽 그림 : 네트워크 2개 / 오른쪽 그림 : 네트워크 1개)

###### 코드 : [Network.cpp](./Network.cpp)
<br>

###### 2019 카카오 개발자 겨울 인턴십
## 2. 불량 사용자
개발팀 내에서 이벤트 개발을 담당하고 있는 "무지"는 최근 진행된 카카오이모티콘 이벤트에 비정상적인 방법으로 당첨을 시도한 응모자들을 발견하였습니다. 이런 응모자들을 따로 모아 **불량 사용자**라는 이름으로 목록을 만들어서 당첨 처리 시 제외하도록 이벤트 당첨자 담당자인 "프로도" 에게 전달하려고 합니다. 이 때 개인정보 보호을 위해 사용자 아이디 중 일부 문자를 '&#42;' 문자로 가려서 전달했습니다. 가리고자 하는 문자 하나에 '&#42;' 문자 하나를 사용하였고 아이디 당 최소 하나 이상의 '&#42;' 문자를 사용하였습니다. "무지"와 "프로도"는 불량 사용자 목록에 매핑된 응모자 아이디를 **제재 아이디** 라고 부르기로 하였습니다.  
예를 들어, 이벤트에 응모한 전체 사용자 아이디 목록이 다음과 같다면  
|응모자 아이디|frodo|fradi|crodo|abc123|frodoc|
|:---|:---|:---|:---|:---|:---|

다음과 같이 불량 사용자 아이디 목록이 전달된 경우,  
|불량 사용자|fr&#42;d&#42;|abc1&#42;&#42;|
|:---|:---|:---|

불량 사용자에 매핑되어 당첨에서 제외되어야 할 제재 아이디 목록은 다음과 같이 두 가지 경우가 있을 수 있습니다.
|제재 아이디|frodo|abc123|
|:---|:---|:---|  

|제재 아이디|fradi|abc123|
|:---|:---|:---|

이벤트 응모자 아이디 목록이 담긴 배열 user_id와 불량 사용자 아이디 목록이 담긴 배열 banned_id가 매개변수로 주어질 때, 당첨에서 제외되어야 할 제재 아이디 목록은 몇가지 경우의 수가 가능한 지 return 하도록 solution 함수를 완성해주세요.  

###### 제한사항
  + user_id 배열의 크기는 1 이상 8 이하입니다.
  + user_id 배열 각 원소들의 값은 길이가 1 이상 8 이하인 문자열입니다.
    - 응모한 사용자 아이디들은 서로 중복되지 않습니다.
    - 응모한 사용자 아이디는 알파벳 소문자와 숫자로만으로 구성되어 있습니다.
  + banned_id 배열의 크기는 1 이상 user_id 배열 크기 이하입니다.
  + banned_id 배열 각 원소들의 값은 길이가 1 이상 8 이하인 문자열입니다.
    - 불량 사용자 아이디는 알파벳 소문자와 숫자, 가리기 위한 문자 '&#42;'로만 이루어져 있습니다.
    - 불량 사용자 아이디는 '&#42;' 문자를 하나 이상 포함하고 있습니다.
    - 불량 사용자 아이디 하나는 응모자 아이디 중 하나에 해당하고 같은 응모자 아이디가 중복해서 제재 아이디 목록에 들어가는 경우는 없습니다.
  + 제재 아이디 목록들을 구했을 때 아이디들이 나열된 순서와 관계없이 아이디 목록의 내용이 동일하다면 같은 것으로 처리하여 하나로 세면 됩니다.

###### 입출력 예
|user_id|banned_id|resut|
|:---|:---|:---|
|["frodo", "fradi", "crodo", "abc123", "frodoc"]|["fr&#42;d&#42;", "abc1&#42;&#42;"]|2|
|["frodo", "fradi", "crodo", "abc123", "frodoc"]|["&#42;rodo", "&#42;rodo", "&#42;&#42;&#42;&#42;&#42;&#42;"]|2|
|["frodo", "fradi", "crodo", "abc123", "frodoc"]|["fr&#42;d&#42;", "&#42;rodo","&#42;&#42;&#42;&#42;&#42;&#42;", "&#42;&#42;&#42;&#42;&#42;&#42;"]|3|

###### 입출력 예에 대한 설명
입출력 예 #1  
문제 설명과 같습니다.  

입출력 예 #2  
다음과 같이 두 가지 경우가 있습니다.  
|제재 아이디|frodo|crodo|abc123|
|:---|:---|:---|:---|

|제재 아이디|frodo|crodo|frodoc|
|:---|:---|:---|:---|

입출력 예 #3  
다음과 같이 세 가지 경우가 있습니다.  
|제재 아이디|frodo|crodo|abc123|frodoc|
|:---|:---|:---|:---|:---|

|제재 아이디|fradi|crodo|abc123|frodoc|
|:---|:---|:---|:---|:---|

|제재 아이디|fradi|frodo|abc123|frodoc|
|:---|:---|:---|:---|:---|

###### 코드 : [Bad_User.cpp](./Bad_User.cpp)
<br>

## 3. 여행경로
주어진 항공권을 모두 이용하여 여행경로를 짜려고 합니다. 항상 "ICN" 공항에서 출발합니다. 항공권 정보가 담긴 2차원 배열 tickets가 매개변수로 주어질 때, 방문하는 공항 경로를 배열에 담아 return 하도록 solution 함수를 작성해주세요.  

###### 제한사항
  + 모든 공항은 알파벳 대문자 3글자로 이루어집니다.
  + 주어진 공항 수는 3개 이상 10,000개 이하입니다.
  + tickets의 각 행 [a,b]는 a공항에서 b공항으로 가는 항공권이 있다는 의미입니다.
  + 주어진 항공권은 모두 사용해야 합니다.
  + 만일 가능한 경로가 2개 이상일 경우 알파벳 순서가 앞서는 경로를 return 합니다.
  + 모든 도시를 방문할 수 없는 경우는 주어지지 않습니다.

###### 입출력 예
|tickets|return|
|:---|:---|
|[["ICN","JFK"],["HND","IAD"],["JFK","HND"]]|["ICN","JFK","HND","IAD"]|ㅜ
|[["ICN","SFO"],["ICN","ATL"],["SFO","ATL"],["ATL","ICN"],["ATL","SFO"]]|["ICN","ATL","ICN","SFO","ATL","SFO"]|

###### 입출력 예 설명
예제 #1  
["ICN","JFK","HND","IAD"] 순으로 방문할 수 있습니다.  

예제 #2  
["ICN","SFO","ATL","ICN","ATL","SFO"] 순으로 방문할 수도 있지만 ["ICN","ATL","ICN","SFO","ATL","SFO"] 가 알파벳 순으로 앞섭니다.  

###### 코드 : [TravelRoute.cpp](./TravelRoute.cpp)
<br>

## 4. 다단계 칫솔 판매
민호는 다단계 조직을 이용하여 칫솔을 판매하고 있습니다. 판매원이 칫솔을 판매하면 그 이익이 피라미드 조직을 타고 조금씩 분배되는 형태의 판매망입니다. 어느정도 판매가 이루어진 후, 조직을 운영하던 민호는 조직 내 누가 얼마만큼의 이득을 가져갔는지가 궁금해졌습니다. 예를 들어, 민호가 운영하고 있는 다단계 칫솔 판매 조직이 아래 그림과 같다고 합시다.  
<img src="https://user-images.githubusercontent.com/39071652/128877818-dda81f69-b626-4e81-93a9-8ffc5d58e1e1.png" width="250">  
민호는 center이며, 파란색 네모는 여덟 명의 판매원을 표시한 것입니다. 각각은 자신을 조직에 참여시킨 추천인에 연결되어 피라미드 식의 구조를 이루고 있습니다. 조직의 이익 분배 규칙은 간단합니다. 모든 판매원은 칫솔의 판매에 의하여 발생하는 이익에서 10% 를 계산하여 자신을 조직에 참여시킨 추천인에게 배분하고 나머지는 자신이 가집니다. 모든 판매원은 자신이 칫솔 판매에서 발생한 이익 뿐만 아니라, 자신이 조직에 추천하여 가입시킨 판매원에게서 발생하는 이익의 10% 까지 자신에 이익이 됩니다. 자신에게 발생하는 이익 또한 마찬가지의 규칙으로 자신의 추천인에게 분배됩니다. 단, 10% 를 계산할 때에는 원 단위에서 절사하며, 10%를 계산한 금액이 1 원 미만인 경우에는 이득을 분배하지 않고 자신이 모두 가집니다.  
예를 들어, 아래와 같은 판매 기록이 있다고 가정하겠습니다. 칫솔의 판매에서 발생하는 이익은 개당 100 원으로 정해져 있습니다.  
|판매원|판매수량|이익금|
|:---|:---|:---|
|young|12|1,200원|
|john|4|400원|
|tod|2|200d원|
|emily|5|500원|
|mary|10|1,000원|

판매원 young 에 의하여 1,200 원의 이익이 발생했습니다. young 은 이 중 10% 에 해당하는 120 원을, 자신을 조직에 참여시킨 추천인인 edward 에게 배분하고 자신은 나머지인 1,080 원을 가집니다. edward 는 young 에게서 받은 120 원 중 10% 인 12 원을 mary 에게 배분하고 자신은 나머지인 108 원을 가집니다. 12 원을 edward 로부터 받은 mary 는 10% 인 1 원을 센터에 (즉, 민호에게) 배분하고 자신은 나머지인 11 원을 가집니다. 이 상태를 그림으로 나타내면 아래와 같습니다.  
<img src="https://user-images.githubusercontent.com/39071652/128878170-350e2b27-aeb1-47a8-a3df-99b2d728c067.png" width="250">  
그 후, 판매원 john 에 의하여 400 원의 이익이 발생합니다. john 은 10% 인 40 원을 센터에 배분하고 자신이 나머지인 360 원을 가집니다. 이 상태를 그림으로 나타내면 아래와 같습니다.  
<img src="https://user-images.githubusercontent.com/39071652/128878423-bd968e4b-173b-47bf-97a6-6a13b8be5340.png" width="250">  
또 그 후에는 판매원 tod 에 의하여 200 원 이익이 발생하는데, tod 자신이 180 원을, 추천인인 jaimie 가 그 중 10% 인 20 원을 받아서 18 원을 가지고, jaimie 의 추천인인 mary 는 2 원을 받지만 이것의 10% 는 원 단위에서 절사하면 배분할 금액이 없기 때문에 mary 는 2 원을 모두 가집니다. 이 상태를 그림으로 나타내면 아래와 같습니다.  
<img src="https://user-images.githubusercontent.com/39071652/128878676-39ed932a-1a50-4bce-b5ca-ef4aafc01761.png" width="250">  
그 다음으로 emily 가 칫솔 판매를 통하여 얻은 이익 500 원은 마찬가지의 규칙에 따라 emily 에게 450 원, mary 에게 45 원, 그리고 센터에 5 원으로 분배됩니다. 이 상태를 그림으로 나타내면 아래와 같습니다.  
<img src="https://user-images.githubusercontent.com/39071652/128878964-600d20b5-e1e9-4108-8203-515ec355719b.png" width="250">  
마지막으로, 판매원 mary 는 1,000 원의 이익을 달성하고, 이 중 10% 인 100 원을 센터에 배분한 후 그 나머지인 900 원을 자신이 가집니다. 이 상태를 그림으로 나타내면 아래와 같습니다.  
<img src="https://user-images.githubusercontent.com/39071652/128879115-f819cb21-6bde-4d0c-be26-0a03608576a2.png" width="250">  
위와 같이 하여 모든 조직 구성원들의 이익 달성 현황 집계가 끝났습니다. 지금까지 얻은 이익을 모두 합한 결과를 그림으로 나타내면 아래와 같습니다.  
<img src="https://user-images.githubusercontent.com/39071652/128879279-58f83c8b-4f21-4118-a942-d777b790d79a.png" width="250">  
이 결과가 민호가 파악하고자 하는 이익 배분 현황입니다.  
각 판매원의 이름을 담은 배열 enroll, 각 판매원을 다단계 조직에 참여시킨 다른 판매원의 이름을 담은 배열 referral, 판매량 집계 데이터의 판매원 이름을 나열한 배열 seller, 판매량 집계 데이터의 판매 수량을 나열한 배열 amount가 매개변수로 주어질 때, 각 판매원이 득한 이익금을 나열한 배열을 return 하도록 solution 함수를 완성해주세요. 판매원에게 배분된 이익금의 총합을 계산하여(정수형으로), 입력으로 주어진 enroll에 이름이 포함된 순서에 따라 나열하면 됩니다.  

###### 제한사항
  + enroll의 길이는 1 이상 10,000 이하입니다.
    - enroll에 민호의 이름은 없습니다. 따라서 enroll의 길이는 민호를 제외한 조직 구성원의 총 수입니다.
  + referral의 길이는 enroll의 길이와 같습니다.
    - referral 내에서 i 번째에 있는 이름은 배열 enroll 내에서 i 번째에 있는 판매원을 조직에 참여시킨 사람의 이름입니다.
    - 어느 누구의 추천도 없이 조직에 참여한 사람에 대해서는 referral 배열 내에 추천인의 이름이 기입되지 않고 **&#45;** 가 기입됩니다. 위 예제에서는 john과 mary가 이러한 예에 해당합니다.
    - enroll에 등장하는 이름은 조직에 참여한 순서에 따릅니다.
    - 즉, 어느 판매원의 이름이 enroll 의 i 번째에 등장한다면, 이 판매원을 조직에 참여시킨 사람의 이름, 즉 referral 의 i 번째 원소는 이미 배열 enroll 의 j 번째 (j < i) 에 등장했음이 보장됩니다.
  + seller의 길이는 1 이상 100,000 이하입니다.
    - seller 내의 i 번째에 있는 이름은 i 번째 판매 집계 데이터가 어느 판매원에 의한 것인지를 나타냅니다.
    - seller 에는 같은 이름이 중복해서 들어있을 수 있습니다.
  + amount의 길이는 seller의 길이와 같습니다.
    - amount 내의 i 번째에 있는 수는 i 번째 판매 집계 데이터의 판매량을 나타냅니다.
    - 판매량의 범위, 즉 amount 의 원소들의 범위는 1 이상 100 이하인 자연수입니다.
  + 칫솔 한 개를 판매하여 얻어지는 이익은 100 원으로 정해져 있습니다.
  + 모든 조직 구성원들의 이름은 10 글자 이내의 영문 알파벳 소문자들로만 이루어져 있습니다.

###### 입출력 예
|enroll|referral|seller|amount|result|
|:---|:---|:---|:---|:---|
|["john", "mary", "edward", "sam", "emily", "jaimie", "tod", "young"]|["-", "-", "mary", "edward", "mary", "mary", "jaimie", "edward"]|["young", "john", "tod", "emily", "mary"]|[12, 4, 2, 5, 10]|[360, 958, 108, 0, 450, 18, 180, 1080]|
|["john", "mary", "edward", "sam", "emily", "jaimie", "tod", "young"]|["-", "-", "mary", "edward", "mary", "mary", "jaimie", "edward"]|["sam", "emily", "jaimie", "edward"]|[2, 3, 5, 4]|[0, 110, 378, 180, 270, 450, 0, 0]|

###### 입출력 예 설명
입출력 예 #1  
문제의 예시와 같습니다.  

입출력 예 #2  
문제에 주어진 예시와 동일한 조직 구성에 조금 다른 판매량 집계를 적용한 것입니다. 이익을 분배하는 규칙이 동일하므로, 간단한 계산에 의하여 표에 보인 결과를 얻을 수 있습니다.  

###### 코드 : [Multi-Level_Toothbrush_Sales.cpp](./Multi-Level_Toothbrush_Sales.cpp)
<br>

###### 2020 카카오 인턴십
## 5. 경주로 건설
건설회사의 설계사인 **죠르디**는 고객사로부터 자동차 경주로 건설에 필요한 견적을 의뢰받았습니다. 제공된 경주로 설계 도면에 따르면 경주로 부지는 **N x N** 크기의 정사각형 격자 형태이며 각 격자는 **1 x 1** 크기입니다. 설계 도면에는 각 격자의 칸은 **0** 또는 **1** 로 채워져 있으며, **0**은 칸이 비어 있음을 **1**은 해당 칸이 벽으로 채워져 있음을 나타냅니다.  
경주로의 출발점은 (0, 0) 칸(좌측 상단)이며, 도착점은 (N-1, N-1) 칸(우측 하단)입니다. 죠르디는 출발점인 (0, 0) 칸에서 출발한 자동차가 도착점인 (N-1, N-1) 칸까지 무사히 도달할 수 있게 중간에 끊기지 않도록 경주로를 건설해야 합니다.  
경주로는 상, 하, 좌, 우로 인접한 두 빈 칸을 연결하여 건설할 수 있으며, 벽이 있는 칸에는 경주로를 건설할 수 없습니다. 이때, 인접한 두 빈 칸을 상하 또는 좌우로 연결한 경주로를 **직선 도로** 라고 합니다. 또한 두 **직선 도로**가 서로 직각으로 만나는 지점을 **코너** 라고 부릅니다.  
건설 비용을 계산해 보니 **직선 도로** 하나를 만들 때는 100원이 소요되며, **코너**를 하나 만들 때는 500원이 추가로 듭니다. 죠르디는 견적서 작성을 위해 경주로를 건설하는 데 필요한 최소 비용을 계산해야 합니다.  
예를 들어, 아래 그림은 **직선 도로** 6개와 **코너** 4개로 구성된 임의의 경주로 예시이며, 건설 비용은 6 x 100 + 4 x 500 = 2600원 입니다.  
<img src="https://user-images.githubusercontent.com/39071652/129212638-6b2fe5fd-2d4a-43e6-a7ef-214ba9b3b30f.png" width="220">  
또 다른 예로, 아래 그림은 **직선 도로** 4개와 **코너** 1개로 구성된 경주로이며, 건설 비용은 4 x 100 + 1 x 500 = 900원 입니다.  
<img src="https://user-images.githubusercontent.com/39071652/129213088-45e37b1c-b570-4c5b-be6d-4896a61011c9.png" width="220">  
도면의 상태(0은 비어 있음, 1은 벽)을 나타내는 2차원 배열 board가 매개변수로 주어질 때, 경주로를 건설하는데 필요한 최소 비용을 return 하도록 solution 함수를 완성해주세요.  

###### 제한사항
  + board는 2차원 정사각 배열로 배열의 크기는 3 이상 25 이하입니다.
  + board 배열의 각 원소의 값은 0 또는 1 입니다.
    - 도면의 가장 왼쪽 상단 좌표는 (0, 0)이며, 가장 우측 하단 좌표는 (N-1, N-1) 입니다.
    - 원소의 값 0은 칸이 비어 있어 도로 연결이 가능함을 1은 칸이 벽으로 채워져 있어 도로 연결이 불가능함을 나타냅니다.
  + board는 항상 출발점에서 도착점까지 경주로를 건설할 수 있는 형태로 주어집니다.
  + 출발점과 도착점 칸의 원소의 값은 항상 0으로 주어집니다.

###### 입출력 예
|board|result|
|:---|:---|
|[[0,0,0],[0,0,0],[0,0,0]]|900|
|[[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,1],[0,0,1,0,0,0,1,0],[0,1,0,0,0,1,0,0],[1,0,0,0,0,0,0,0]]|3800|
|[[0,0,1,0],[0,0,0,0],[0,1,0,1],[1,0,0,0]]|2100|
|[[0,0,0,0,0,0],[0,1,1,1,1,0],[0,0,1,0,0,0],[1,0,0,1,0,1],[0,1,0,0,0,1],[0,0,0,0,0,0]]|3200|

###### 입출력 예에 대한 설명
입출력 예 #1  
본문의 예시와 같습니다.  

입출력 예 #2  
<img src="https://user-images.githubusercontent.com/39071652/129213449-ba3fa23d-a5e2-4fd4-a943-5d687123d57c.png" width="220">  
위와 같이 경주로를 건설하면 **직선 도로** 18개, **코너** 4개로 총 3800원이 듭니다.  

입출력 예 #3  
<img src="https://user-images.githubusercontent.com/39071652/129213627-5022110e-2352-4c0c-aeee-0ca0aec5f017.png" width="220">  
위와 같이 경주로를 건설하면 **직선 도로** 6개, **코너** 3개로 총 2100원이 듭니다.  

입출력 예 #4  
<img src="https://user-images.githubusercontent.com/39071652/129213762-b673a7b8-4c36-4da5-880b-9051320233f6.png" width="220">  
붉은색 경로와 같이 경주로를 건설하면 **직선 도로** 12개, **코너** 4개로 총 3200원이 듭니다. 만약, 파란색 경로와 같이 경주로를 건설한다면 **직선 도로** 10개, **코너** 5개로 총 3500원이 들며, 더 많은 비용이 듭니다.  

###### 코드 : [RaceTrack_Construction.cpp](./RaceTrack_Construction.cpp)
<br>

###### 2020 KAKAO BLIND RECRUITMENT
## 6. 블록 이동하기
로봇개발자 *"무지"* 는 한 달 앞으로 다가온 "카카오배 로봇경진대회"에 출품할 *로봇*을 준비하고 있습니다. 준비 중인 로봇은 **2 x 1** 크기의 로봇으로 "무지"는 *"0"* 과 *"1"* 로 이루어진 *N x N* 크기의 지도에서 **2 x 1** 크기인 로봇을 움직여 (N, N) 위치까지 이동 할 수 있도록 프로그래밍을 하려고 합니다. 로봇이 이동하는 지도는 가장 왼쪽, 상단의 좌표를 *(1, 1)* 로 하며 지도 내에 표시된 숫자 *"0"* 은 빈칸을 *"1"* 은 벽을 나타냅니다. 로봇은 벽이 있는 칸 또는 지도 밖으로는 이동할 수 없습니다. 로봇은 처음에 아래 그림과 같이 좌표 *(1, 1)* 위치에서 가로방향으로 놓여있는 상태로 시작하며, 앞뒤 구분없이 움직일 수 있습니다.  
<img src="https://user-images.githubusercontent.com/39071652/131354320-c1ec477b-6253-4a93-b8e9-d8ee45797835.png" width="300">  
로봇이 움직일 때는 현재 놓여있는 상태를 유지하면서 이동합니다. 예를 들어, 위 그림에서 오른쪽으로 한 칸 이동한다면 *(1, 2), (1, 3)* 두 칸을 차지하게 되며, 아래로 이동한다면 *(2, 1), (2, 2)* 두 칸을 차지하게 됩니다. 로봇이 차지하는 두 칸 중 어느 한 칸이라도 *(N, N)* 위치에 도착하면 됩니다.  
로봇은 다음과 같이 조건에 따라 회전이 가능합니다.  
<img src="https://user-images.githubusercontent.com/39071652/131354432-f2758de1-c579-4f8d-9c71-9251da607a5b.png" width="300">  
위 그림과 같이 로봇은 90도씩 회전할 수 있습니다. 단, 로봇이 차지하는 두 칸 중, 어느 칸이든 축이 될 수 있지만, 회전하는 방향(축이 되는 칸으로부터 대각선 방향에 있는 칸)에는 벽이 없어야 합니다. 로봇이 한 칸 이동하거나 90도 회전하는 데는 걸리는 시간은 정확히 1초 입니다.  
*"0"* 과 *"1"* 로 이루어진 지도인 board가 주어질 때, 로봇이 *(N, N)* 위치까지 이동하는데 필요한 최소 시간을 return 하도록 solution 함수를 완성해주세요.  

###### 제한사항
  - board의 한 변의 길이는 5 이상 100 이하입니다.
  - board의 원소는 0 또는 1입니다.
  - 로봇이 처음에 놓여 있는 칸 (1,1),(1,2)는 항상 0으로 주어집니다.
  - 로봇이 항상 목적지에 도착할 수 있는 경우만 입력으로 주어집니다.

###### 입출력 예
|board|result|
|:---|:---|
|[[0, 0, 0, 1, 1],[0, 0, 0, 1, 0],[0, 1, 0, 1, 1],[1, 1, 0, 0, 1],[0, 0, 0, 0, 0]]|7|

###### 입출력 예에 대한 설명
문제에 주어진 예시와 같습니다.  
로봇이 오른쪽으로 한 칸 이동 후, (1, 3) 칸을 축으로 반시계 방향으로 90도 회전합니다. 다시, 아래쪽으로 3칸 이동하면 로봇은 (4, 3), (5, 3) 두 칸을 차지하게 됩니다. 이제 (5, 3)을 축으로 시계 방향으로 90도 회전 후, 오른쪽으로 한 칸 이동하면 (N, N)에 도착합니다. 따라서 목적지에 도달하기까지 최소 7초가 걸립니다.  

###### 코드 : [Move_Blocks.cpp](./Move_Blocks.cpp)
<br>

###### 위클리 챌린지(3주차)
## 7. 퍼즐 조각 채우기
테이블 위에 놓인 퍼즐 조각을 게임 보드의 빈 공간에 적절히 올려놓으려 합니다. 게임 보드와 테이블은 모두 각 칸이 1x1 크기인 정사각 격자 모양입니다. 이때, 다음 규칙에 따라 테이블 위에 놓인 퍼즐 조각을 게임 보드의 빈칸에 채우면 됩니다.  
  - 조각은 한 번에 하나씩 채워 넣습니다.
  - 조각을 회전시킬 수 있습니다.
  - 조각을 뒤집을 수는 없습니다.
  - 게임 보드에 새로 채워 넣은 퍼즐 조각과 인접한 칸이 비어있으면 안 됩니다.

다음은 퍼즐 조각을 채우는 예시입니다.  
<img src="https://user-images.githubusercontent.com/39071652/132697718-b4b4d075-bed8-4012-bc27-3c769d022973.png" width="450">  
위 그림에서 왼쪽은 현재 게임 보드의 상태를, 오른쪽은 테이블 위에 놓인 퍼즐 조각들을 나타냅니다. 테이블 위에 놓인 퍼즐 조각들 또한 마찬가지로 [상,하,좌,우]로 인접해 붙어있는 경우는 없으며, 흰 칸은 퍼즐이 놓이지 않은 빈 공간을 나타냅니다. 모든 퍼즐 조각은 격자 칸에 딱 맞게 놓여있으며, 격자 칸을 벗어나거나, 걸쳐 있는 등 잘못 놓인 경우는 없습니다.  
이때, 아래 그림과 같이 3,4,5번 조각을 격자 칸에 놓으면 규칙에 어긋나므로 불가능한 경우입니다.  
<img src="https://user-images.githubusercontent.com/39071652/132697605-2c52e342-75e4-4b04-8808-2ae0ddc0978f.png" width="450">  
  - 3번 조각을 놓고 4번 조각을 놓기 전에 위쪽으로 인접한 칸에 빈칸이 생깁니다.
  - 5번 조각의 양 옆으로 인접한 칸에 빈칸이 생깁니다.

다음은 규칙에 맞게 최대한 많은 조각을 게임 보드에 채워 넣은 모습입니다.  
<img src="https://user-images.githubusercontent.com/39071652/132697750-8bc96969-0f20-4ee0-b4f4-fe4e3cefdf02.png" width="450">  
최대한 많은 조각을 채워 넣으면 총 14칸을 채울 수 있습니다.  
현재 게임 보드의 상태 **game_board**, 테이블 위에 놓인 퍼즐 조각의 상태 **table**이 매개변수로 주어집니다. 규칙에 맞게 최대한 많은 퍼즐 조각을 채워 넣을 경우, 총 몇 칸을 채울 수 있는지 return 하도록 solution 함수를 완성해주세요.  

###### 제한사항
  - 3 ≤ **game_board**의 행 길이 ≤ 50
  - **game_board**의 각 열 길이 = **game_board**의 행 길이
    + 즉, 게임 보드는 정사각 격자 모양입니다.
    + **game_board**의 모든 원소는 0 또는 1입니다.
    + 0은 빈칸, 1은 이미 채워진 칸을 나타냅니다.
    + 퍼즐 조각이 놓일 빈칸은 1 x 1 크기 정사각형이 최소 1개에서 최대 6개까지 연결된 형태로만 주어집니다.
  - **table**의 행 길이 = **game_board**의 행 길이
  - **table**의 각 열 길이 = **table**의 행 길이
    + 즉, 테이블은 game_board와 같은 크기의 정사각 격자 모양입니다.
    + table의 모든 원소는 0 또는 1입니다.
    + 0은 빈칸, 1은 조각이 놓인 칸을 나타냅니다.
    + 퍼즐 조각은 1 x 1 크기 정사각형이 최소 1개에서 최대 6개까지 연결된 형태로만 주어집니다.
  - **game_board**에는 반드시 하나 이상의 빈칸이 있습니다.
  - **table**에는 반드시 하나 이상의 블록이 놓여 있습니다.

###### 입출력 예
|game_board|table|result|
|:---|:---|:---|
|[[1,1,0,0,1,0],[0,0,1,0,1,0],[0,1,1,0,0,1],[1,1,0,1,1,1],[1,0,0,0,1,0],[0,1,1,1,0,0]]|[[1,0,0,1,1,0],[1,0,1,0,1,0],[0,1,1,0,1,1],[0,0,1,0,0,0],[1,1,0,1,1,0],[0,1,0,0,0,0]]|14|
|[[0,0,0],[1,1,0],[1,1,1]]|[[1,1,1],[1,0,0],[0,0,0]]|0|

###### 입출력 예 설명
입출력 예 #1  
입력은 다음과 같은 형태이며, 문제의 예시와 같습니다.  
<img src="https://user-images.githubusercontent.com/39071652/132697817-526887e0-5cbd-4833-82e5-4413bd74c301.png" width="450">  

입출력 예 #2
블록의 회전은 가능하지만, 뒤집을 수는 없습니다.  

<br>

###### 월드 코드 챌린지 시즌2
## 8. 모두 0으로 만들기
각 점에 가중치가 부여된 트리가 주어집니다. 당신은 다음 연산을 통하여, 이 트리의 모든 점들의 가중치를 0으로 만들고자 합니다.  
  - 임의의 연결된 두 점을 골라서 한쪽은 1 증가시키고, 다른 한쪽은 1 감소시킵니다.

하지만, 모든 트리가 위의 행동을 통하여 모든 점들의 가중치를 0으로 만들 수 있는 것은 아닙니다. 당신은 주어진 트리에 대해서 해당 사항이 가능한지 판별하고, 만약 가능하다면 최소한의 행동을 통하여 모든 점들의 가중치를 0으로 만들고자 합니다.  
트리의 각 점의 가중치를 의미하는 1차원 정수 배열 **a**와 트리의 간선 정보를 의미하는 **edges**가 매개변수로 주어집니다. 주어진 행동을 통해 트리의 모든 점들의 가중치를 0으로 만드는 것이 불가능하다면 -1을, 가능하다면 최소 몇 번만에 가능한지를 찾아 return 하도록 solution 함수를 완성해주세요. (만약 처음부터 트리의 모든 정점의 가중치가 0이라면, 0을 return 해야 합니다.)  

###### 제한사항
  - a의 길이는 2 이상 300,000 이하입니다.
    + a의 모든 수는 각각 -1,000,000 이상 1,000,000 이하입니다.
    + **a[i]** 는 i번 정점의 가중치를 의미합니다.
  - edges의 행의 개수는 (a의 길이 - 1)입니다. 
    + edges의 각 행은 **[u, v]** 2개의 정수로 이루어져 있으며, 이는 u번 정점과 v번 정점이 간선으로 연결되어 있음을 의미합니다.
    + edges가 나타내는 그래프는 항상 트리로 주어집니다.


###### 입출력 예
|a|edges|result|
|:---|:---|:---|
|[-5,0,2,1,2]|[[0,1],[3,4],[2,3],[0,3]]|9|
|[0,1,0]|[[0,1],[1,2]]|-1|

###### 입출력 예 설명
입출력 예 #1  
다음 그림은 주어진 트리의 모든 정점의 가중치를 0으로 만드는 과정을 나타낸 것입니다.  
<img src="https://user-images.githubusercontent.com/39071652/133105741-180d68d6-b9d6-4577-a342-e49a89600932.png" width="400">  
1. 2번 정점과 3번 정점을 선택하여 2번 정점은 1 감소시키고, 3번 정점은 1 증가시킵니다. (2번 반복)
2. 3번 정점과 4번 정점을 선택하여 4번 정점은 1 감소시키고, 3번 정점은 1 증가시킵니다. (2번 반복)
3. 0번 정점과 3번 정점을 선택하여 3번 정점은 1 감소시키고, 0번 정점은 1 증가시킵니다. (5번 반복)
4. 모든 정점의 가중치를 0으로 만드는 데 필요한 최소 행동 횟수는 9번이므로, 9를 return 해야 합니다.

입출력 예 #2  
주어진 트리는 모든 정점의 가중치를 0으로 만드는 것이 불가능하므로, -1을 return 해야 합니다.  

###### 코드 : [Make_All_Zeros.cpp](./Make_All_Zeros.cpp)
<br>

### 그래프 Graph
## 1. 순위
n명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.  
선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때 정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요.  

###### 제한사항
  + 선수의 수는 1명 이상 100명 이하입니다.
  + 경기 결과는 1개 이상 4,500개 이하입니다.
  + results 배열 각 행 [A,B]는 A선수가 B선수를 이겼다는 의미입니다.
  + 모든 경기 결과에는 모순이 없습니다.

###### 입출력 예
|n|results|return|
|:---|:---|:---|
|5|[[4,3],[4,2],[3,2],[1,2],[2,5]]|2|

###### 입출력 예 설명
2번 선수는 [1,3,4] 선수에게 패배했고 5번 선수에게 승리했기 때문에 4위입니다.  
5번 선수는 4위인 2번 선수에게 패배했기 때문에 5위입니다.

###### 코드 : [Rank.cpp](./Rank.cpp)
<br>

## 2. 가장 먼 노드
n개의 노드가 있는 그래프가 있습니다. 각 노드는 1부터 n까지 번호가 적혀있습니다. 1번 노드에서 가장 멀리 떨어진 노드의 갯수를 구하려고 합니다. 가장 멀리 떨어진 노드란 최단경로로 이동했을 때 간선의 개수가 가장 많은 노드들을 의미합니다.  
노드의 개수 n, 간선에 대한 정보가 담긴 2차원 배열 vertex가 매개변수로 주어질 때, 1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지를 return 하도록 solution 함수를 작성해주세요.

###### 제한사항
  + 노드의 개수 n은 2 이상 20,000 이하입니다.
  + 간선은 양방향이며 총 1개 이상 50,000개 이하의 간선이 있습니다.
  + vertex 배열 각 행 [a,b]는 a번 노드와 b번 노드 사이에 간선이 있다는 의미입니다.

###### 입출력 예
|n|vertex|return|
|:---|:---|:---|
|6|[[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]]|3|

###### 입출력 예 설명
예제의 그래프를 표현하면 아래 그림과 같고, 1번 노드에서 가장 멀리 떨어진 노드는 4,5,6번 노드입니다.  
<img src="https://user-images.githubusercontent.com/39071652/127142583-6e561fa7-13f8-4fed-8b01-644f1f6d436e.png" width="150">

###### 코드 : [Farthest_Node.cpp](./Farthest_Node.cpp)
<br>

### 이분탐색 Binary Search
## 1. 입국심사
n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다. 처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다. 모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.  
입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.

###### 제한사항
  + 입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.
  + 각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.
  + 심사관은 1명 이상 100,000명 이하입니다.

###### 입출력 예
|n|times|return|
|:---|:---|:---|
|6|[7,10]|28|

###### 입출력 예 설명
가장 첫 사람은 바로 심사를 받으러 갑니다. 7분이 되었을 때, 첫 번째 심사대가 비고 3번째 사람이 심사를 받습니다. 10분이 되었을 때, 두 번째 심사대가 비고 4번째 사람이 심사를 받습니다. 14분이 되었을 때, 첫 번째 심사대가 비고 5번째 사람이 심사를 받습니다. 20분이 되었을 때, 두 번째 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고 1분을 더 기다린 후에 첫 번째 심사대에서 심사를 받으면 28분에 모든 사람의 심사가 끝납니다.

###### 코드 : [Immigration.cpp](./Immigration.cpp)
<br>

###### 2019 카카오 개발자 겨울 인턴십
## 2. 징검다리 건너기
카카오 초등학교의 "니니즈 친구들"이 "라이언" 선생님과 함께 가을 소풍을 가는 중에 *징검다리*가 있는 개울을 만나서 건너편으로 건너려고 합니다. "라이언" 선생님은 "니니즈 친구들"이 무사히 징검다리를 건널 수 있도록 다음과 같이 규칙을 만들었습니다.  
  - 징검다리는 일렬로 놓여 있고 각 징검다리의 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다.
  - 디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다.
  - 단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다.

"니니즈 친구들"은 개울의 왼쪽에 있으며, 개울의 오른쪽 건너편에 도착해야 징검다리를 건넌 것으로 인정합니다. "니니즈 친구들"은 한 번에 한 명씩 징검다리를 건너야 하며, 한 친구가 징검다리를 모두 건넌 후에 그 다음 친구가 건너기 시작합니다.  
디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones와 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k가 매개변수로 주어질 때, 최대 몇 명까지 징검다리를 건널 수 있는지 return 하도록 solution 함수를 완성해주세요.  

###### 제한사항
  - 징검다리를 건너야 하는 니니즈 친구들의 수는 무제한 이라고 간주합니다.
  - stones 배열의 크기는 1 이상 200,000 이하입니다.
  - stones 배열 각 원소들의 값은 1 이상 200,000,000 이하인 자연수입니다.
  - k는 1 이상 stones의 길이 이하인 자연수입니다.

###### 입출력 예
|stones|k|result|
|:---|:---|:---|
|[2, 4, 5, 3, 2, 1, 4, 2, 5, 1]|3|3|

###### 입출력 예에 대한 설명
입출력 예 #1  
첫 번째 친구는 다음과 같이 징검다리를 건널 수 있습니다.  
<img src="https://user-images.githubusercontent.com/39071652/133450707-504ea932-e7f2-42d6-b12a-f2e12ec26277.png" width="600">  
첫 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.  
두 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.  
<img src="https://user-images.githubusercontent.com/39071652/133450774-db1e7bb3-74f0-44b7-9af4-4d7792b1674f.png" width="600">  
두 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.  
세 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.  
<img src="https://user-images.githubusercontent.com/39071652/133450813-df7fe987-e8d2-4b90-aa71-112a211849a5.png" width="600">  
세 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.  
네 번째 친구가 징검다리를 건너려면, 세 번째 디딤돌에서 일곱 번째 디딤돌로 네 칸을 건너뛰어야 합니다. 하지만 k = 3 이므로 건너뛸 수 없습니다.  
<img src="https://user-images.githubusercontent.com/39071652/133450848-10c51b01-80c8-490d-8114-8c589e44571b.png" width="600">  
따라서 최대 3명이 디딤돌을 모두 건널 수 있습니다.  

###### 코드 : [Crossing_the_Stepping_Stone.cpp](./Crossing_the_Stepping_Stone.cpp)
<br>

### 탐욕법(Greedy)
## 1. 단속카메라
고속도로를 이동하는 모든 차량이 고속도로를 이용하면서 단속용 카메라를 한 번은 만나도록 카메라를 설치하려고 합니다. 고속도로를 이동하는 차량의 경로 routes가 매개변수로 주어질 때, 모든 차량이 한 번은 단속용 카메라를 만나도록 하려면 최소 몇 대의 카메라를 설치해야 하는지를 return 하도록 solution 함수를 완성하세요.

###### 제한사항
  + 차량의 대수는 1대 이상 10,000대 이하입니다.
  + routes에는 차량의 이동 경로가 포함되어 있으며 routes[i][0]에는 i번째 차량이 고속도로에 진입한 지점, routes[i][1]에는 i번째 차량이 고속도로에서 나간 지점이 적혀 있습니다.
  + 차량의 진입/진출 지점에 카메라가 설치되어 있어도 카메라를 만난 것으로 간주합니다.
  + 차량의 진입 지점, 진출 지점은 -30,000 이상 30,000 이하입니다.

###### 입출력 예
|routes|return|
|:---|:---|
|[[-20,15],[-14,-5],[-18,-13],[-5,-3]]|2|

###### 입출력 예 설명
-5 지점에 카메라를 설치하면 두 번째, 네 번째 차량이 카메라를 만납니다. -15 지점에 카메라를 설치하면 첫 번째, 세 번째 차량이 카메라를 만납니다.

###### 코드 : [CrackdownCamera.cpp](./CrackdownCamera.cpp)
<br>

### 트리(Tree)
###### 2019 KAKAO BLIND RECRUITMENT
## 1. 길 찾기 게임
전무로 승진한 라이언은 기분이 너무 좋아 프렌즈를 이끌고 특별 휴가를 가기로 했다. 내친김에 여행 계획까지 구상하던 라이언은 재미있는 게임을 생각해냈고 역시 전무로 승진할만한 인재라고 스스로에게 감탄했다.  
라이언이 구상한(그리고 아마도 라이언만 즐거울만한) 게임은, 카카오 프렌즈를 두 팀으로 나누고, 각 팀이 같은 곳을 다른 순서로 방문하도록 해서 먼저 순회를 마친 팀이 승리하는 것이다. 그냥 지도를 주고 게임을 시작하면 재미가 덜해지므로, 라이언은 방문할 곳의 2차원 좌표 값을 구하고 각 장소를 이진트리의 노드가 되도록 구성한 후, 순회 방법을 힌트로 주어 각 팀이 스스로 경로를 찾도록 할 계획이다.  
라이언은 아래와 같은 특별한 규칙으로 트리 노드들을 구성한다.  
  - 트리를 구성하는 모든 노드의 x, y 좌표 값은 정수이다.
  - 모든 노드는 서로 다른 x값을 가진다.
  - 같은 레벨(level)에 있는 노드는 같은 y 좌표를 가진다.
  - 자식 노드의 y 값은 항상 부모 노드보다 작다.
  - 임의의 노드 V의 왼쪽 서브 트리(left subtree)에 있는 모든 노드의 x값은 V의 x값보다 작다.
  - 임의의 노드 V의 오른쪽 서브 트리(right subtree)에 있는 모든 노드의 x값은 V의 x값보다 크다.

아래 예시를 확인해보자.  
라이언의 규칙에 맞게 이진트리의 노드만 좌표 평면에 그리면 다음과 같다. (이진트리의 각 노드에는 1부터 N까지 순서대로 번호가 붙어있다.)  
<img src="https://user-images.githubusercontent.com/39071652/130810810-49b771b5-bf8e-48d4-abfb-ec121d6be8d0.png" width="400">  
이제, 노드를 잇는 간선(edge)을 모두 그리면 아래와 같은 모양이 된다.  
<img src="https://user-images.githubusercontent.com/39071652/130810969-7032e472-e525-4012-a273-5c761632d223.png" width="400">  
위 이진트리에서 전위 순회(preorder), 후위 순회(postorder)를 한 결과는 다음과 같고, 이것은 각 팀이 방문해야 할 순서를 의미한다.  
  - 전위 순회 : 7, 4, 6, 9, 1, 8, 5, 2, 3
  - 후위 순회 : 9, 6, 5, 8, 1, 4, 3, 2, 7

다행히 두 팀 모두 머리를 모아 분석한 끝에 라이언의 의도를 간신히 알아차렸다.  
그러나 여전히 문제는 남아있다. 노드의 수가 예시처럼 적다면 쉽게 해결할 수 있겠지만, 예상대로 라이언은 그렇게 할 생각이 전혀 없었다.  
이제 당신이 나설 때가 되었다. 곤경에 빠진 카카오 프렌즈를 위해 이진트리를 구성하는 노드들의 좌표가 담긴 배열 nodeinfo가 매개변수로 주어질 때, 노드들로 구성된 이진트리를 전위 순회, 후위 순회한 결과를 2차원 배열에 순서대로 담아 return 하도록 solution 함수를 완성하자.  

###### 제한사항
  - nodeinfo는 이진트리를 구성하는 각 노드의 좌표가 1번 노드부터 순서대로 들어있는 2차원 배열이다.
    + nodeinfo의 길이는 **1** 이상 **10,000** 이하이다.
    + nodeinfo[i] 는 i + 1번 노드의 좌표이며, [x축 좌표, y축 좌표] 순으로 들어있다.
    + 모든 노드의 좌표 값은 **0** 이상 **100,000** 이하인 정수이다.
    + 트리의 깊이가 **1,000** 이하인 경우만 입력으로 주어진다.
    + 모든 노드의 좌표는 문제에 주어진 규칙을 따르며, 잘못된 노드 위치가 주어지는 경우는 없다.

###### 입출력 예
|nodeinfo|result|
|:---|:---|
|[[5,3],[11,5],[13,3],[3,5],[6,1],[1,3],[8,6],[7,2],[2,2]]|[[7,4,6,9,1,8,5,2,3],[9,6,5,8,1,4,3,2,7]]|

###### 입출력 예 설명
입출력 예 #1  
문제에 주어진 예시와 같다.

###### 코드 : [Wayfinding_Game.cpp](./Wayfinding_Game.cpp)
<br>

### 기타
###### 2018 KAKAO BLIND RECRUITMENT
## 1. 추석 트래픽
이번 추석에도 시스템 장애가 없는 명절을 보내고 싶은 어피치는 서버를 증설해야 할지 고민이다. 장애 대비용 서버 증설 여부를 결정하기 위해 작년 추석 기간인 9월 15일 로그 데이터를 분석한 후 초당 최대 처리량을 계산해보기로 했다. **초당 최대 처리량**은 요청의 응답 완료 여부에 관계없이 임의 시간부터 1초(=1,000밀리초)간 처리하는 요청의 최대 개수를 의미한다.

###### 입력 형식
  + *solution* 함수에 전달되는 lines 배열은 **N**(1≤**N**≤2,000)개의 로그 문자열로 되어 있으며, 각 로그 문자열마다 요청에 대한 응답완료시간 **S**와 처리시간 **T**가 공백으로 구분되어 있다.
  + 응답완료시간 **S**는 작년 추석인 2016년 9월 15일만 포함하여 고정 길이 *2016-09-15 hh:mm:ss.sss* 형식으로 되어 있다.
  + 처리시간 **T**는 *0.1s*, *0.312s*, *2s*와 같이 최대 소수점 셋째 자리까지 기록하며 뒤에는 초 단위를 의미하는 *s*로 끝난다.
  + 예를 들어, 로그 문자열 *2016-09-15 03:10:33.020 0.011s*은 "2016년 9월 15일 오전 3시 10분 **33.010초**"부터 "2016년 9월 15일 오전 3시 10분 **33.020초**까지 "**0.011초**" 동안 처리된 요청을 의미한다. **(처리시간은 시작시간과 끝시간을 포함)**
  + 서버에는 타임아웃이 3초로 적용되어 있기 때문에 처리시간은 **0.001≤T≤3.000**이다.
  + *lines* 배열은 응답완료시간 **S**를 기준으로 오름차순 정렬되어 있따.

###### 출력 형식
  + *solution* 함수에서는 로그 데이터 *lines* 배열에 대해 **초당 최대 처리량**을 리턴한다.

###### 입출력 예제
###### 예제1
  + 입력: ["2016-09-15 01:00:04.001 2.0s", "2016-09-15 01:00:07.000 2s"]
  + 출력: 1

###### 예제2
  + 입력: ["2016-09-15 01:00:04.002 2.0s","2016-09-15 01:00:07.000 2s"]
  + 출력: 2
  + 설명: 처리시간은 시작시간과 끝시간을 **포함**하므로 첫 번째 로그는 *01:00:02.003 ~ 01:00:04.002*에서 2초동안 처리되었으며, 두 번째 로그는 *01:00:05.001 ~ 01:00:07:000*에서 2초동안 처리된다. 따라서, 첫 번째 로그가 끝나는 시점과 두 번째 로그가 시작하는 시점의 구간인 *01:00:04.002 ~ 01:00:05.001* 1초동안 최대 2개가 된다.

###### 예제3
  + 입력: ["2016-09-15 20:59:57.421 0.351s","2016-09-15 20:59:58.233 1.181s","2016-09-15 20:59:58.299 0.8s","2016-09-15 20:59:58.688 1.041s","2016-09-15 20:59:59.591 1.412s","2016-09-15 21:00:00.464 1.466s","2016-09-15 21:00:00.741 1.581s","2016-09-15 21:00:00.748 2.31s","2016-09-15 21:00:00.966 0.381s","2016-09-15 21:00:02.066 2.62s"]
  + 출력: 7
  + 설명: 아래 타임라인 그림에서 빨간색으로 표시된 1초 각 구간의 처리량을 구해보면 (1)은 4개, (2)는 7개, (3)는 2개임을 알 수 있다. 따라서 **초당 최대 처리량**은 7이 되며, 최대 처리량을 갖는 1초 구간은 여러 개 존재할 수 있으므로 이 문제에서는 구간이 아닌 개수만 출력한다.
<img src="https://user-images.githubusercontent.com/39071652/126509678-7a06cf02-e342-455c-87ab-7e31fb4872ea.png" width="400"> 

###### 코드 : [Chuseok_Traffic.cpp](./Chuseok_Traffic.cpp)
<br>

###### 2020 카카오 인턴십
## 2. 보석 쇼핑
개발자 출신으로 세계 최고의 갑부가 된 어피치는 스트레스를 받을 때면 이를 풀기 위해 오프라인 매장에 쇼핑을 하러 가곤 합니다. 어피치는 쇼핑을 할 때면 매장 진열대의 특정 범위의 물건들을 모두 싹쓸이 구매하는 습관이 있습니다.  
어느 날 스트레스를 풀기 위해 보석 매장에 쇼핑을 하러 간 어피치는 이전처럼 진열대의 특정 범위의 보석을 모두 구매하되 특별히 아래 목적을 달성하고 싶었습니다.  
**진열된 모든 종류의 보석을 적어도 1개 이상 포함하는 가장 짧은 구간을 찾아서 구매**  
예를 들어 아래 진열대는 4종류의 보석(RUBY, DIA, EMERALD, SAPPHIRE) 8개가 진열된 예시입니다.  

|진열대 번호|1|2|3|4|5|6|7|8|
|:---|:---|:---|:---|:---|:---|:---|:---|:---|
|보석이름|DIA|RUBY|**RUBY**|**DIA**|**DIA**|**EMERALD**|**SAPPHIRE**|DIA|

진열대의 3번부터 7번까지 5개의 보석을 구매하면 모든 종류의 보석을 적어도 하나 이상씩 포함하게 됩니다.  
진열대의 3, 4, 6, 7번의 보석만 구매하는 것은 중간에 특정 구간(5번)이 빠지게 되므로 어피치의 쇼핑 습관에 맞지 않습니다.  
진열대 번호 순서대로 보석들의 이름이 저장된 배열 gems가 매개변수로 주어집니다. 이때 모든 보석을 하나 이상 포함하는 가장 짧은 구간을 찾아서 return 하도록 solution 함수를 완성해주세요.  
가장 짧은 구간의 **시간 진열대 번호**와 **끝 진열대 번호**를 차례대로 배열에 담아서 return 하도록 하며, 만약 가장 짧은 구간이 여러 개라면 **시작 진열대 번호**가 가장 작은 구간을 return 합니다.

###### 제한사항
  + gems 배열의 크기는 1 이상 100,000 이하입니다.
    - gems 배열의 각 원소는 진열대에 나열된 보석을 나타냅니다.
    - gems 배열에는 1번 진열대부터 진열대 번호 순서대로 보석이름이 차례대로 저장되어 있습니다.
    - gems 배열의 각 원소에는 길이가 1 이상 10 이하인 알파벳 대문자로만 구성된 문자열입니다.

###### 입출력 예  
|gems|result|
|:---|:---|
|["DIA", "RUBY", "RUBY", "DIA", "DIA", "EMERALD", "SAPPHIRE", "DIA"]|[3, 7]|
|["AA", "AB", "AC", "AA", "AC"]|[1, 3]|
|["XYZ", "XYZ", "XYZ"]|[1, 1]|
|["ZZZ", "YYY", "NNNN", "YYY", "BBB"]|[1, 5]|

###### 입출력 예에 대한 설명
입출력 예 #1  
문제 예시와 같습니다.  

입출력 예 #2  
3종류의 보석(AA, AB, AC)을 모두 포함하는 가장 짧은 구간은 [1, 3], [2, 4]가 있습니다. **시작 진열대 번호**가 더 작은 [1, 3]을 return 해주어야 합니다.  

입출력 예 #3  
1종류의 보석(XYZ)을 포함하는 가장 짧은 구간은 [1, 1], [2, 2], [3, 3]이 있습니다. **시작 진열대 번호**가 가장 작은 [1, 1]을 return 해주어야 합니다.  

입출력 예 #4  
4종류의 보석(ZZZ, YYY, NNNN, BBB)을 모두 포함하는 구간은 [1, 5]가 유일합니다. 그러므로 [1, 5]를 return 해주어야 합니다.  

###### 코드 : [Jewelry_Shopping.cpp](./Jewelry_Shopping.cpp)
<br>

###### 2020 KAKAO BLIND RECRUITMENT
## 3. 자물쇠와 열쇠
고고학자인 "**튜브**"는 고대 유적지에서 보물과 유적이 가득할 것으로 추정되는 비밀의 문을 발견하였습니다. 그런데 문을 열려고 살펴보니 특이한 형태의 **자물쇠**로 잠겨 있었고 문 앞에는 특이한 형태의 **열쇠**와 함께 자물쇠를 푸는 방법에 대해 다음과 같이 설명해 주는 종이가 발견되었습니다.  
잠겨있는 자물쇠는 격자 한 칸의 크기가 *1x1*인 *NxN* 크기의 정사각 격자 형태이고 특이한 모양의 열쇠는 *MxM* 크기인 정사각 격자 형태로 되어 있습니다.  
자물쇠에는 홈이 파여 있고 열쇠 또한 홈과 돌기 부분이 있습니다. 열쇠는 회전과 이동이 가능하며 열쇠의 돌기 부분을 자물쇠의 홈 부분에 딱 맞게 채우면 자물쇠가 열리게 되는 구조입니다. 자물쇠 영역을 벗어난 부분에 있는 열쇠의 홈과 돌기는 자물쇠를 여는 데 영향을 주지 않지만, 자물쇠 영역 내에서는 열쇠의 돌기 부분과 자물쇠의 홈 부분이 정확하게 일치해야 하며 열쇠의 돌기와 자물쇠의 돌기가 만나서는 안됩니다. 또한 자물쇠의 모든 홈을 채워 비어있는 곳이 없어야 자물쇠를 열 수 있습니다.  
열쇠를 나타내는 2차원 배열 key와 자물쇠를 나타내는 2차원 배열 lock이 매개변수로 주어질 때, 열쇠로 자물쇠를 열 수 있으면 true를, 열 수 없으면 false를 return 하도록 solution 함수를 완성해주세요.

###### 제한사항
  + key는 M x M (3 ≤ M ≤ 20, M은 자연수)크기 2차원 배열입니다.
  + lock은 N x N (3 ≤ N ≤ 20, N은 자연수)크기 2차원 배열입니다.
  + M은 항상 N 이하입니다.
  + key와 lock의 원소는 0 또는 1로 이루어져 있습니다.
    - 0은 홈 부분, 1은 돌기 부분을 나타냅니다.

###### 입출력 예
|key|lock|result|
|:---|:---|:---|
|[[0,0,0],[1,0,0],[0,1,1]]|[[1,1,1],[1,1,0],[1,0,1]]|true|

###### 입출력 예에 대한 설명
<img src="https://user-images.githubusercontent.com/39071652/127193245-629a0941-45a4-4639-859a-e59dc09eaf21.png" width="150"> <img src="https://user-images.githubusercontent.com/39071652/127193282-71971cf9-3ef2-4311-be61-3b962e976c72.png" width="150">  
key를 시계 방향으로 90도 회전하고, 오른쪽으로 한 칸, 아래로 한 칸 이동하면 lock의 홈 부분을 정확히 모두 채울 수 있습니다.

###### 코드 : [Lock_n_Key.cpp](./Lock_n_Key.cpp)
<br>

###### 2021 카카오 채용연계형 인턴십
## 4. 표 편집
업무용 소프트웨어를 개발하는 니니즈웍스의 인턴인 앙몬드는 명령어 기반으로 표의 행을 선택, 삭제, 복구하는 프로그램을 작성하는 과제를 맡았습니다. 세부 요구 사항은 다음과 같습니다.  
<img src="https://user-images.githubusercontent.com/39071652/130322531-75c95453-f09f-4c4e-ad2e-2b723f7194c1.png" width="150">  
위 그림에서 파란색으로 칠해진 칸은 현재 선택된 행을 나타냅니다. 단, 한 번에 한 행만 선택할 수 있으며, 표의 범위(0행 ~ 마지막 행)를 벗어날 수 없습니다. 이때, 다음과 같은 명령어를 이용하여 표를 편집합니다.  
  + **"U X"** : 현재 선택된 행에서 X칸 위에 있는 행을 선택합니다.
  + **"D X"** : 현재 선택된 행에서 X칸 아래에 있는 행을 선택합니다.
  + **"C"** : 현재 선택된 행을 삭제한 후, 바로 아래 행을 선택합니다. 단, 삭제된 행이 가장 마지막 인 경우 바로 윗 행을 선택합니다.
  + **"Z"** : 가장 최근에 삭제된 행을 원래대로 복구합니다. <u>단, 현재 선택된 행은 바뀌지 않습니다.</u>

예를 들어 위 표에서 **"D 2"** 를 수행할 경우 아래 그림의 왼쪽처럼 4행이 선택되며, **"C"** 를 수행하면 선택된 행을 삭제하고, 바로 아래 행이었던 "네오"가 적힌 행을 선택합니다(4행이 삭제되면서 아래 있던 행들이 하나씩 밀려 올라오고, 수정된 표에서 다시 4행을 선택하는 것과 동일합니다).  
<img src="https://user-images.githubusercontent.com/39071652/130322631-24f724b3-4532-451c-a773-a1e8a246e0ef.png" width="150"> <img src="https://user-images.githubusercontent.com/39071652/130322645-85a17f7b-6b2e-4d9a-b72c-ae7cf2ac0232.png" width="150">  
다음으로 **"U 3"** 을 수행한 다음 **"C"** 를 수행한 후의 표 상태는 아래 그림과 같습니다.  
<img src="https://user-images.githubusercontent.com/39071652/130322763-b3a8e602-3da3-4a08-81b6-4d1b19a705b0.png" width="150"> <img src="https://user-images.githubusercontent.com/39071652/130322772-8922cc3a-83c3-4cc5-94b6-ec4874c34b69.png" width="150">  
다음으로 **"D 4"** 를 수행한 다음 **"C"** 를 수행한 후의 표 상태는 아래 그림과 같습니다. 5행이 표의 마지막 행 이므로, 이 경우 바로 윗 행을 선택하는 점에 주의합니다.  
<img src="https://user-images.githubusercontent.com/39071652/130322798-506a55a5-e3c0-4ddc-b698-dc29d54c8709.png" width="150"> <img src="https://user-images.githubusercontent.com/39071652/130322804-e5259894-8275-4baf-a6de-c583e7ad5bd7.png" width="150">  
다음으로 **"U 2"** 를 수행하면 현재 선택된 행은 2행이 됩니다. 아래 첫 번째 상태에서 **"Z"** 를 수행할 경우 가장 최근에 제거된 **"라이언"** 이 적힌 행이 원래대로 복구됩니다. 다시한번 **"Z"** 를 수행하면 그 다음으로 최근에 제거된 **"콘"** 이 적힌 행이 원래대로 복구됩니다. 이때, 현재 선택된 행은 바뀌지 않는 점에 주의하세요.  
<img src="https://user-images.githubusercontent.com/39071652/130322826-cb8bc612-393c-45da-98a6-7266bc9a3d61.png" width="150"> <img src="https://user-images.githubusercontent.com/39071652/130322890-e613d611-92c4-4ba9-ab7f-9b0cdc3c0c8e.png" width="150"> <img src="https://user-images.githubusercontent.com/39071652/130322913-9820e880-a352-4584-a957-f6b65ef42c0a.png" width="150">  
이때, 최종 표의 상태와 처음 주어진 표의 상태를 비교하여 삭제되지 않은 행은 **"O"** , 삭제된 행은 **"X"** 로 표시하면 다음과 같습니다.  
<img src="https://user-images.githubusercontent.com/39071652/130323291-d14d3e2b-95ab-4147-82de-3de9d2d192ad.png" width="150">  
처음 표의 행 개수를 나타내는 정수 n, 처음에 선택된 행의 위치를 나타내는 정수 k, 수행한 명령어들이 담긴 문자열 배열 cmd가 매개변수로 주어질 때, 모든 명령어를 수행한 후 표의 상태와 처음 주어진 표의 상태를 비교하여 삭제되지 않은 행은 O, 삭제된 행은 X로 표시하여 문자열 형태로 return 하도록 solution 함수를 완성해주세요.  

###### 제한사항
  + 5 ≤ **n** ≤ 1,000,000
  + 0 ≤ **k** < **n**
  + 1 ≤ **cmd** 의 원소 개수 ≤ 200,000
    - **cmd** 의 각 원소는 **"U X"** , **"D X"** , **"C"** , **"Z"** 중 하나입니다.
    - X는 1 이상 300,000 이하인 자연수이며 0으로 시작하지 않습니다.
    - X가 나타내는 자연수에 ','는 주어지지 않습니다. 예를 들어 123,456의 경우 123456으로 주어집니다.
    - **cmd** 에 등장하는 모든 X들의 값을 합친 결과가 1,000,000 이하인 경우만 입력으로 주어집니다.
    - 표의 모든 행을 제거하여, 행이 하나도 남지 않는 경우는 입력으로 주어지지 않습니다.
    - 본문에서 각 행이 제거되고 복구되는 과정을 보다 자연스럽게 보이기 위해 **"이름"** 열을 사용하였으나, **"이름"** 열의 내용이 실제 문제를 푸는 과정에 필요하지는 않습니다. **"이름"** 열에는 서로 다른 이름들이 중복없이 채워져 있다고 가정하고 문제를 해결해 주세요.
  + 표의 범위를 벗어나는 이동은 입력으로 주어지지 않습니다.
  + 원래대로 복구할 행이 없을 때(즉, 삭제된 행이 없을 때) "Z"가 명령어로 주어지는 경우는 없습니다.
  + 정답은 표의 0행부터 n-1행까지에 해당되는 O, X를 순서대로 이어붙인 문자열 형태로 return 해주세요.

###### 정확성 테스트 케이스 제한사항
  + 5 ≤ **n** ≤ 1,000
  + 1 ≤ **cmd** 의 원소 개수 ≤ 1,000

###### 효율성 테스트 케이스 제한사항
  + 주어진 조건 외 추가 제한사항 없습니다.

###### 입출력 예
|n|k|cmd|result|
|:---|:---|:---|:---|
|8|2|["D 2","C","U 3","C","D 4","C","U 2","Z","Z"]|"OOOOXOOO"|
|8|2|["D 2","C","U 3","C","D 4","C","U 2","Z","Z","U 1","C"]|"OOXOXOOO"|

###### 입출력 예 설명
입출력 예 #1  
문제의 예시와 같습니다.  

입출력 예 #2  
다음은 9번째 명령어까지 수행한 후의 표 상태이며, 이는 입출력 예 #1과 같습니다.  
<img src="https://user-images.githubusercontent.com/39071652/130323138-bab8afce-fcbe-4462-a917-8b6cded92603.png" width="150">  
10번째 명령어 **"U 1"** 을 수행하면 **"어피치"** 가 적힌 2행이 선택되며, 마지막 명령어 **"C"** 를 수행하면 선택된 행을 삭제하고, 바로 아래 행이었던 **"제이지"** 가 적힌 행을 선택합니다.  
<img src="https://user-images.githubusercontent.com/39071652/130323191-3940935c-3294-4a0f-80ea-06c3948d9758.png" width="150"> <img src="https://user-images.githubusercontent.com/39071652/130323232-76300043-efb9-4db2-81c9-4d3026b3f941.png" width="150">  
따라서 처음 주어진 표의 상태와 최종 표의 상태를 비교하면 다음과 같습니다.  
<img src="https://user-images.githubusercontent.com/39071652/130323286-f04d4482-27c0-4d8c-acc0-2d5248205e87.png" width="150">  

###### 제한시간 안내
  + 정확성 테스트 : 10초
  + 효율성 테스트 : 언어별로 작성된 정답 코드의 실행 시간의 적정 배수

###### 코드 : [Table_Edit.cpp](./Table_Edit.cpp)
<br>

###### Summer/Winter Coding(~2018)
## 5. 기지국 설치
N개의 아파트가 일렬로 쭉 늘어서 있습니다. 이 중에서 일부 아파트 옥상에는 4g 기지국이 설치되어 있습니다. 기술이 발전해 5g 수요가 높아져 4g 기지국을 5g 기지국으로 바꾸려 합니다. 그런데 5g 기지국은 4g 기지국보다 전달 범위가 좁아, 4g 기지국을 5g 기지국으로 바꾸면 어떤 아파트에는 전파가 도달하지 않습니다.  
예를 들어 11개의 아파트가 쭉 늘어서 있고, [4, 11] 번째 아파트 옥상에는 4g 기지국이 설치되어 있습니다. 만약 이 4g 기지국이 전파 도달 거리가 1인 5g 기지국으로 바뀔 경우 모든 아파트에 전파를 전달할 수 없습니다. (전파의 도달 거리가 W일 땐, 기지국이 설치된 아파트를 기준으로 전파를 양쪽으로 W만큼 전달할 수 있습니다.)  
  - 초기에, 1, 2, 6, 7, 8, 9번째 아파트에는 전파가 전달되지 않습니다.
<img src="https://user-images.githubusercontent.com/39071652/131524506-567c4e72-3a99-4c75-bfc8-7fbbf868b1cc.png" width="300">  

  - 1, 7, 9번째 아파트 옥상에 기지국을 설치할 경우, 모든 아파트에 전파를 전달할 수 있습니다.  
<img src="https://user-images.githubusercontent.com/39071652/131524746-fc12ea02-6f07-4776-a161-1c942868f34b.png" width="300">  

  - 3개의 아파트보다 더 많은 아파트 옥상에 기지국을 설치할 경우에도 모든 아파트에 전파를 전달할 수 있습니다.  
<img src="https://user-images.githubusercontent.com/39071652/131524777-b4537b0e-a29d-48d7-8f91-fbcd72acc00b.png" width="300">  

이때, 우리는 기지국을 최소로 설치하면서 모든 아파트에 전파를 전달하려고 합니다. 위의 예시에선 최소 3개의 아파트 옥상에 기지국을 설치해야 모든 아파트에 전파를 전달할 수 있습니다.  
아파트의 개수 N, 현재 기지국이 설치된 아파트의 번호가 담긴 1차원 배열 stations, 전파의 도달 거리 W가 매개변수로 주어질 때, 모든 아파트에 전파를 전달하기 위해 증설해야 할 기지국 개수의 최솟값을 리턴하는 solution 함수를 완성해주세요.  

###### 제한사항
  - N: 200,000,000 이하의 자연수
  - stations의 크기: 10,000 이하의 자연수
  - stations는 오름차순으로 정렬되어 있고, 배열에 담긴 수는 N보다 같거나 작은 자연수입니다.
  - W: 10,000 이하의 자연수

###### 입출력 예
|N|stations|W|answer|
|:---|:---|:---|:---|
|11|[4,11]|1|3|
|16|[9]|2|3|

###### 입출력 예 설명
입출력 예 #1  
문제의 예시와 같습니다  

입출력 예 #2  
  - 초기에, 1~6, 12~16번째 아파트에는 전파가 전달되지 않습니다.
<img src="https://user-images.githubusercontent.com/39071652/131524895-02325acc-de54-402f-8969-83c9273a5c2a.png" width="400">  

  - 3, 6, 14번째 아파트 옥상에 기지국을 설치할 경우 모든 아파트에 전파를 전달할 수 있습니다.
<img src="https://user-images.githubusercontent.com/39071652/131525410-1cfd0bfc-463f-4b05-8fe9-dc48e0e8bb3c.png" width="400">

###### 코드 : [Base_station_Installation.cpp](./Base_station_Installation.cpp)
<br>

## 6. 가장 긴 팰린드롬
앞뒤를 뒤집어도 똑같은 문자열을 팰린드롬(palindrome)이라고 합니다. 문자열 s가 주어질 때, s의 부분문자열(Substring)중 가장 긴 팰린드롬의 길이를 return 하는 solution 함수를 완성해 주세요.  
예를들면, 문자열 s가 "abcdcba"이면 7을 return하고 "abacde"이면 3을 return합니다.  

###### 제한사항
  - 문자열 s의 길이 : 2,500 이하의 자연수
  - 문자열 s는 알파벳 소문자로만 구성

###### 입출력 예
|s|answer|
|:---|:---|
|"abcdcba"|7|
|"abacde"|3|

###### 입출력 예 설명
입출력 예 #1  
4번째자리 'd'를 기준으로 문자열 s 전체가 팰린드롬이 되므로 7을 return합니다.  

입출력 예 #2  
2번째자리 'b'를 기준으로 "aba"가 팰린드롬이 되므로 3을 return합니다.  

###### 코드 : [Longest_Palindrome.cpp](./Longest_Palindrome.cpp)
<br>

## 7. 숫자 게임
xx 회사의 2xN명의 사원들은 N명씩 두 팀으로 나눠 숫자 게임을 하려고 합니다. 두 개의 팀을 각각 A팀과 B팀이라고 하겠습니다. 숫자 게임의 규칙은 다음과 같습니다.  
  - 먼저 모든 사원이 무작위로 자연수를 하나씩 부여받습니다.
  - 각 사원은 딱 한 번씩 경기를 합니다.
  - 각 경기당 A팀에서 한 사원이, B팀에서 한 사원이 나와 서로의 수를 공개합니다. 그때 숫자가 큰 쪽이 승리하게 되고, 승리한 사원이 속한 팀은 승점을 1점 얻게 됩니다.
  - 만약 숫자가 같다면 누구도 승점을 얻지 않습니다.

전체 사원들은 우선 무작위로 자연수를 하나씩 부여받았습니다. 그다음 A팀은 빠르게 출전순서를 정했고 자신들의 출전 순서를 B팀에게 공개해버렸습니다. B팀은 그것을 보고 자신들의 최종 승점을 가장 높이는 방법으로 팀원들의 출전 순서를 정했습니다. 이때의 B팀이 얻는 승점을 구해주세요.  
A 팀원들이 부여받은 수가 출전 순서대로 나열되어있는 배열 **A**와 i번째 원소가 B팀의 i번 팀원이 부여받은 수를 의미하는 배열 **B**가 주어질 때, B 팀원들이 얻을 수 있는 최대 승점을 return 하도록 solution 함수를 완성해주세요.  

###### 제한사항
  - A와 B의 길이는 같습니다.
  - A와 B의 길이는 1 이상 100,000 이하입니다.
  - A와 B의 각 원소는 1 이상 1,000,000,000 이하의 자연수입니다.

###### 입출력 예
|A|B|result|
|:---|:---|:---|
|[5,1,3,7]|[2,2,6,8]|3|
|[2,2,2,2]|[1,1,1,1]|0|

###### 입출력 예 설명
입출력 예 #1  
<img src="https://user-images.githubusercontent.com/39071652/135974408-ba5ca4c4-1409-476c-b65f-cf094d5e99ad.png" width="400">  
A 팀은 숫자 5를 부여받은 팀원이 첫번째로 출전하고, 이어서 1,3,7을 부여받은 팀원들이 차례대로 출전합니다.  
B 팀원들을 4번, 2번, 3번, 1번의 순서대로 출전시킬 경우 팀원들이 부여받은 숫자들은 차례대로 8,2,6,2가 됩니다. 그러면, 첫 번째, 두 번째, 세 번째 경기에서 승리하여 3점을 얻게 되고, 이때가 최대의 승점입니다.  

입출력 예 #2  
B 팀원들을 어떤 순서로 출전시켜도 B팀의 승점은 0점입니다.  

###### 코드 : [Number_Game.cpp](./Number_Game.cpp)
<br>

## 8. 최고의 집합
자연수 n 개로 이루어진 중복 집합(multi set, 편의상 이후에는 "집합"으로 통칭) 중에 다음 두 조건을 만족하는 집합을 최고의 집합이라고 합니다.  
  1. 각 원소의 합이 S가 되는 수의 집합
  2. 위 조건을 만족하면서 각 원소의 곱 이 최대가 되는 집합

예를 들어서 자연수 2개로 이루어진 집합 중 합이 9가 되는 집합은 다음과 같이 4개가 있습니다. 
{ 1, 8 }, { 2, 7 }, { 3, 6 }, { 4, 5 }  
그중 각 원소의 곱이 최대인 { 4, 5 }가 최고의 집합입니다.  

집합의 원소의 개수 n과 모든 원소들의 합 s가 매개변수로 주어질 때, 최고의 집합을 return 하는 solution 함수를 완성해주세요. 

###### 제한사항
  - 최고의 집합은 오름차순으로 정렬된 1차원 배열(list, vector) 로 return 해주세요.
  - 만약 최고의 집합이 존재하지 않는 경우에 크기가 1인 1차원 배열(list, vector) 에 **-1**을 채워서 return 해주세요.
  - 자연수의 개수 n은 1 이상 10,000 이하의 자연수입니다.
  - 모든 원소들의 합 s는 1 이상, 100,000,000 이하의 자연수입니다.

###### 입출력 예
|n|s|result|
|:---|:---|:---|
|2|9|[4,5]|
|2|1|[-1]|
|2|8|[4,4]|

###### 입출력 예 설명
입출력 예#1  
문제의 예시와 같습니다.  

입출력 예#2  
자연수 2개를 가지고는 합이 1인 집합을 만들 수 없습니다. 따라서 -1이 들어있는 배열을 반환합니다.  

입출력 예#3  
자연수 2개로 이루어진 집합 중 원소의 합이 8인 집합은 다음과 같습니다.  
{ 1, 7 }, { 2, 6 }, { 3, 5 }, { 4, 4 }  
그중 각 원소의 곱이 최대인 { 4, 4 }가 최고의 집합입니다.  

###### 코드 : [Best_Set.cpp](./Best_Set.cpp)
<br>

--------
<br>

##### 문제출처 및 이용 사이트
> 프로그래머스 [Programmers](https://programmers.co.kr)  

##### 사용 프로그램
> Visual Studio 2019  
