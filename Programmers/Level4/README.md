Level 4 코딩테스트 연습

목표
> Level 3 & 4  
> Visual Studio 2019 사용

### 목차
- 이분탐색
  - [1. 징검다리](#1-징검다리)
- 깊이/너비 우선 탐색
  - [1. 지형 이동](#1-지형-이동)
  - [2. 트리 트리오 중간값](#2-트리-트리오-중간값)
- 트라이
  - [1. 자동완성](#1-자동완성)
  - [2. 가사 검색](#2-가사-검색)
- 동적계획법
  - [1. 단어 퍼즐](#1-단어-퍼즐)
  - [2. 도둑질](#2-도둑질)
  - [3. 3 x n 타일링](#3-3-x-n-타일링)
  - [4. 최적의 행렬 곱셈](#6-최적의-행렬-곱셈)
- 기타
  - [1. 무지의 먹방 라이브](#1-무지의-먹방-라이브)
  - [2. 호텔 방 배정](#2-호텔-방-배정)
  - [3. 올바른 괄호의 갯수](#3-올바른-괄호의-갯수)
  - [4. 쿠키 구입](#4-쿠키-구입)
  - [5. 숫자 블록](#5-숫자-블록)
<br>

# 문제
### 이분탐색 Binary Search
## 1. 징검다리
출발지점부터 distance만틈 떨어진 곳에 도착지점이 있습니다. 그리고 그 사이에는 바위들이 놓여있습니다. 바위 중 몇 개를 제거하려고 합니다. 예를 들어, 도착지점이 25만큼 떨어져 있고, 바위가 [2, 14, 11, 21, 17] 지점에 놓여있을 때 바위 2개를 제거하면 출발지점, 도착지점, 바위 간의 거리가 아래와 같습니다.  
|제거한 바위의 위치|각 바위 사이의 거리|거리의 최솟값|
|:---|:---|:---|
|[21,17]|[2,9,3,11]|2|
|[2,21]|[11,3,3,8]|3|
|[2,11]|[14,3,4,4]|3|
|[11,21]|[2,12,3,8]|2|
|[2,14]|[11,6,4,4]|4|

위에서 구한 거리의 최솟값 중에 가장 큰 값은 4입니다.  
출발지점부터 도착지점까지의 거리 distance, 바위들이 있는 위치를 담은 배열 rocks, 제거할 바위의 수 n이 매개변수로 주어질 때, 바위를 n개 제거한 뒤 각 지점 사이의 거리의 최솟값 중에 가장 큰 값을 return 하도록 solution 함수를 작성해주세요.  

###### 제한사항
  + 도착지점까지의 거리 distance는 1 이상 1,000,000,000 이하입니다.
  + 바위는 1개 이상 50,000개 이하가 있습니다.
  + n은 1 이상 *바위의 개수* 이하입니다.

###### 입출력 예
|distance|rocks|n|return|
|:---|:---|:---|:---|
|25|[2,14,11,21,17]|2|4|

###### 입출력 예 설명
문제에 나온 예와 같습니다.

###### 코드 : [Stepping_Stone.cpp](./Stepping_Stone.cpp)
<br>


### 깊이/너비 우선 탐색(Depth/Breadth First Search); DFS/BFS
###### Summer/Winter Coding(2019)
## 1. 지형 이동
N x N 크기인 정사각 격자 형태의 지형이 있습니다. 각 격자 칸의 1 x 1 크기이며, 숫자가 하나씩 적혀있습니다. 격자 칸에 적힌 숫자는 그 칸의 높이를 나타냅니다.  
이 지형의 아무 칸에서나 출발해 모든 칸을 방문하는 탐험을 떠나려 합니다. 칸을 이동할 때는 상, 하, 좌, 우로 한 칸씩 이동할 수 있는데, 현재 칸과 이동하려는 칸의 높이 차가 height 이하여야 합니다. 높이 차가 height 보다 많이 나는 경우에는 사다리를 설치해서 이동할 수 있습니다. 이때, 사다리를 설치하는데 두 격자 칸의 높이차만큼 비용이 듭니다. 따라서, 최대한 적은 비용이 들도록 사다리를 설치해서 모든 칸으로 이동 가능하도록 해야 합니다. 설치할 수 있는 사다리 개수에 제한은 없으며, 설치한 사다리는 철거하지 않습니다.  
각 격자칸의 높이가 담긴 2차원 배열 land와 이동 가능한 최대 높이차 height가 매개변수로 주어질 때, 모든 칸을 방문하기 위해 필요한 사다리 설치 비용의 최솟값을 return 하도록 solution 함수를 완성해주세요.

###### 제한사항
  + land는 N x N 크기인 2차원 배열입니다.
  + land의 최소 크기는 4 x 4, 최대 크기는 300 x 300입니다.
  + land의 원소는 각 격자 칸의 높이를 나타냅니다.
  + 격자 칸의 높이는 1 이상 10,000 이하인 자연수입니다.
  + height는 1 이상 10,000 이하인 자연수입니다.

###### 입출력 예
|land|height|result|
|:---|:---|:---|
|[[1,4,8,10],[5,5,5,5],[10,10,10,10],[10,10,10,20]]|3|15|
|[[10,11,10,11],[2,21,20,10],[1,20,21,11],[2,1,2,1]]|1|18|

###### 입출력 예 설명
입출력 예 #1  
각 칸의 높이는 다음과 같으며, 높이차가 3 이하인 경우 사다리 없이 이동이 가능합니다.  
<img src="https://user-images.githubusercontent.com/39071652/127616083-4dcfcf44-aa1e-41af-ae20-78c4350fe856.png" width="200">  
위 그림에서 사다리를 이용하지 않고 이동 가능한 범위는 같은 색으로 칠해져 있습니다. 예를 들어 (1행 2열) 높이 4인 칸에서 (1행 3열) 높이 8인 칸으로 직접 이동할 수는 없지만, 높이가 5인 칸을 이용하면 사다리를 사용하지 않고 이동할 수 있습니다. 따라서 다음과 같이 사다리 두 개만 설치하면 모든 칸을 방문할 수 있고 최소 비용은 15가 됩니다.  
  + 높이 5인 칸 높이 10인 칸 : 비용 5
  + 높이 10인 칸 높이 20인 칸 : 비용 10

입출력 예 #2  
각 칸의 높이는 다음과 같으며, 높이차가 1 이하인 경우 사다리 없이 이동이 가능합니다.  
<img src="https://user-images.githubusercontent.com/39071652/127616126-2aecd8d9-34b1-4679-89c9-090c846e4022.png" width="200">  
위 그림과 같이 (2행 1열) → (1행 1열), (1행 2열) → (2행 2열) 두 곳에 사다리를 설치하면 설치비용이 18로 최소가 됩니다.

###### 코드 : [Terrain_Movement.cpp](./Terrain_Movement.cpp)
<br>

###### 월드 코드 챌린지 시즌1
## 2. 트리 트리오 중간값
n개의 점으로 이루어진 트리가 있습니다. 이때, 트리 상에서 다음과 같은 것들을 정의합니다.  
  + 어떤 두 점 사이의 거리는, 두 점을 잇는 경로 상 간선의 개수로 정의합니다.
  + 임의의 3개의 점 a, b, c에 대한 함수 f(a,b,c)의 값을 a와 b 사이의 거리, b와 c 사이의 거리, c와 a 사이의 거리, 3개 값의 중간값으로 정의합니다.

트리의 정점의 개수 n과 트리의 간선을 나타내는 2차원 정수 배열 edges가 매개변수로 주어집니다. 주어진 트리에서 임의의 3개의 점을 뽑아 만들 수 있는 모든 f값 중에서, 제일 큰 값을 구해 return 하도록 solution 함수를 완성해주세요.  

###### 제한사항
  + n은 3 이상 250,000 이하입니다.
  + edges의 행의 개수는 n-1 입니다.
    - edges의 각 행은 [v1,v2] 2개의 정수로 이루어져 있으며, 이는 v1번 정점과 v2번 정점 사이에 간선이 있음을 의미합니다.
    - v1, v2는 각각 1 이상 n 이하입니다.
    - v1, v2는 다른 수입니다.
    - 입력으로 주어지는 그래프는 항상 트리입니다.

###### 입출력 예
|n|edges|result|
|:---|:---|:---|
|4|[[1,2],[2,3],[3,4]]|2|
|5|[[1,5],[2,5],[3,5],[4,5]]|2|

###### 입출력 예 설명
입출력 예 #1  
다음 그림은 입력으로 주어진 트리를 나타낸 것입니다.  
<img src="https://user-images.githubusercontent.com/39071652/129475006-9cfa7389-8e21-4efc-b9f4-fbd6c27ced3e.png" width="400">  
다음 표는 주어진 트리에서 나올 수 있는 모든 f값의 경우를 나열한 것입니다. (단, a, b, c의 순서만 다른 경우는 f값이 동일하기 때문에 표에서 제외)  
|a|b|c|a ~ b 거리|b ~ c 거리|c ~ a 거리|f(a,b,c)|
|:---|:---|:---|:---|:---|:---|:---|
|1|2|3|1|1|2|1|
|1|2|4|1|2|3|2|
|1|3|4|2|1|3|2|
|2|3|4|1|1|2|1|

따라서, 2를 return 해야 합니다.  

입출력 예 #2  
다음 그림은 입력으로 주어진 트리를 나타낸 것입니다.  
<img src="https://user-images.githubusercontent.com/39071652/129475050-014d934f-f0e2-40e8-a67e-95c40b49ec7d.png" width="200">  
f값에 사용될 3개의 점으로 (1, 2, 3), (2, 3, 4) 등을 고를 때 가장 큰 값인 2를 얻을 수 있으므로, 2를 return 해야 합니다.  

###### 코드 : [Tree_Trio_Median.cpp](./Tree_Trio_Median.cpp)
<br>

### 트라이(Trie)
###### 2018 KAKAO BLIND RECRUITMENT
## 1. 자동완성
포털 다음에서 검색어 자동완성 기능을 넣고 싶은 라이언은 한 번 입력된 문자열을 학습해서 다음 입력 때 활용하고 싶어 졌다. 예를 들어, **go** 가 한 번 입력되었다면, 다음 사용자는 **g** 만 입력해도 **go**를 추천해주므로 **o**를 입력할 필요가 없어진다! 단, 학습에 사용된 단어들 중 앞부분이 같은 경우에는 어쩔 수 없이 다른 문자가 나올 때까지 입력을 해야 한다. 효과가 얼마나 좋을지 알고 싶은 라이언은 학습된 단어들을 찾을 때 몇 글자를 입력해야 하는지 궁금해졌다.  
예를 들어, 학습된 단어들이 아래와 같을 때  

```
go
gone
guild
```
  - **go**를 찾을 때 **go**를 모두 입력해야 한다.
  - **gone**을 찾을 때 **gon**까지 입력해야 한다. (**gon**이 입력되기 전까지는 **go**인지 **gone**인지 확신할 수 없다.)
  - **guild**를 찾을 때는 **gu**까지만 입력하면 **guild**가 완성된다.

이 경우 총 입력해야 할 문자의 수는 **7** 이다.  
라이언을 도와 위와 같이 문자열이 입력으로 주어지면 학습을 시킨 후, 학습된 단어들을 순서대로 찾을 때 몇 개의 문자를 입력하면 되는지 계산하는 프로그램을 만들어보자.  

###### 입력 형식
학습과 검색에 사용될 중복 없는 단어 **N**개가 주어진다.  
모든 단어는 알파벳 소문자로 구성되며 단어의 수 **N**과 단어들의 길이의 총합 **L**의 범위는 다음과 같다.  
  - 2 <= **N** <= 100,000
  - 2 <= **L** <= 1,000,000

###### 출력 형식
단어를 찾을 때 입력해야 할 총 문자수를 리턴한다.  

###### 입출력 예제
|words|result|
|:---|:---|
|["go","gone","guild"]|7|
|["abc","def","ghi","jklm"]|4|
|["word","war","warrior","world"]|15|

###### 입출력 설명
  - 첫 번째 예제는 본문 설명과 같다.
  - 두 번째 예제에서는 모든 단어들이 공통된 부분이 없으므로, 가장 앞글자만 입력하면 된다.
  - 세 번째 예제는 총 **15**자를 입력해야 하고 설명은 아래와 같다.
    + **word**는 **word** 모두 입력해야 한다.
    + **war**는 **war**까지 모두 입력해야 한다.
    + **warrior**는 **warr**까지만 입력하면 된다.
    + **world**는 **worl**까지 입력해야 한다. (**word**와 구분되어야 함을 명심하자)

###### 코드 : [Autocomplete.cpp](./Autocomplete.cpp)
<br>

###### 2020 KAKAO BLIND RECRUITMENT
## 2. 가사 검색
친구들로부터 천재 프로그래머로 불리는 "프로도"는 음악을 하는 친구로부터 자신이 좋아하는 노래 가사에 사용된 단어들 중에 특정 키워드가 몇 개 포함되어 있는지 궁금하니 프로그램으로 개발해 달라는 제안을 받았습니다.
그 제안 사항 중, 키워드는 와일드카드 문자중 하나인 '?'가 포함된 패턴 형태의 문자열을 뜻합니다. 와일드카드 문자인 '?'는 글자 하나를 의미하며, 어떤 문자에도 매치된다고 가정합니다. 예를 들어 **"fro??"** 는 **"frodo"**, **"front"**, **"frost"** 등에 매치되지만 **"frame"**, **"frozen"** 에는 매치되지 않습니다.  
가사에 사용된 모든 단어들이 담긴 배열 **words**와 찾고자 하는 키워드가 담긴 배열 **queries**가 주어질 때, 각 키워드 별로 매치된 단어가 몇 개인지 순서대로 배열에 담아 반환하도록 **solution** 함수를 완성해 주세요.  

###### 가사 단어 제한사항
  - **words**의 길이(가사 단어의 개수)는 2 이상 100,000 이하입니다.
  - 각 가사 단어의 길이는 1 이상 10,000 이하로 빈 문자열인 경우는 없습니다.
  - 전체 가사 단어 길이의 합은 2 이상 1,000,000 이하입니다.
  - 가사에 동일 단어가 여러 번 나올 경우 중복을 제거하고 **words**에는 하나로만 제공됩니다.
  - 각 가사 단어는 오직 알파벳 소문자로만 구성되어 있으며, 특수문자나 숫자는 포함하지 않는 것으로 가정합니다.

###### 검색 키워드 제한사항
  - **queries**의 길이(검색 키워드 개수)는 2 이상 100,000 이하입니다.
  - 각 검색 키워드의 길이는 1 이상 10,000 이하로 빈 문자열인 경우는 없습니다.
  - 전체 검색 키워드 길이의 합은 2 이상 1,000,000 이하입니다.
  - 검색 키워드는 중복될 수도 있습니다.
  - 각 검색 키워드는 오직 알파벳 소문자와 와일드카드 문자인 **'?'** 로만 구성되어 있으며, 특수문자나 숫자는 포함하지 않는 것으로 가정합니다.
  - 검색 키워드는 와일드카드 문자인 **'?'** 가 하나 이상 포함돼 있으며, **'?'** 는 각 검색 키워드의 접두사 아니면 접미사 중 하나로만 주어집니다.
    + 예를 들어 **"??odo"**, **"fro??"**, **"?????"** 는 가능한 키워드입니다.
    + 반면에 **"frodo"**(**'?'** 가 없음), **"fr?do"**(**'?'** 가 중간에 있음), **"?ro??"**(**'?'** 가 양쪽에 있음)는 불가능한 키워드입니다.

###### 입출력 예
|words|queries|result|
|:---|:---|:---|
|["frodo", "front", "frost", "frozen", "frame", "kakao"]|["fro??", "????o", "fr???", "fro???", "pro?"]|[3, 2, 4, 1, 0]|

###### 입출력 예에 대한 설명
  - **"fro??"** 는 **"frodo"**, **"front"**, **"frost"** 에 매치되므로 3입니다.
  - **"????o"** 는 **"frodo"**, **"kakao"** 에 매치되므로 2입니다.
  - **"fr???"** 는 **"frodo"**, **"front"**, **"frost"**, **"frame"** 에 매치되므로 4입니다
  - **"fro???"** 는 **"frozen"** 에 매치되므로 1입니다
  - **"pro?"** 는 매치되는 가사 단어가 없으므로 0 입니다.

###### 코드 : [Lyrics_Search.cpp](./Lyrics_Search.cpp)
<br>

### 동적계획법(Dynamic Programming); DP
###### 2017 팁스타운
## 1. 단어 퍼즐
단어 퍼즐은 주어진 단어 조각들을 이용해서 주어진 문장을 완성하는 퍼즐입니다. 이때, 주어진 각 단어 조각들은 각각 무한개씩 있다고 가정합니다. 예를 들어 주어진 단어 조각이 [“ba”, “na”, “n”, “a”]인 경우 "ba", "na", "n", "a" 단어 조각이 각각 무한개씩 있습니다. 이때, 만들어야 하는 문장이 “banana”라면 “ba”, “na”, “n”, “a”의 4개를 사용하여 문장을 완성할 수 있지만, “ba”, “na”, “na”의 3개만을 사용해도 “banana”를 완성할 수 있습니다. 사용 가능한 단어 조각들을 담고 있는 배열 strs와 완성해야 하는 문자열 t가 매개변수로 주어질 때, 주어진 문장을 완성하기 위해 사용해야 하는 단어조각 개수의 최솟값을 return 하도록 solution 함수를 완성해 주세요. 만약 주어진 문장을 완성하는 것이 불가능하면 -1을 return 하세요.

###### 제한사항
  + strs는 사용 가능한 단어 조각들이 들어있는 배열로, 길이는 1 이상 100 이하입니다.
  + strs의 각 원소는 사용 가능한 단어조각들이 중복 없이 들어있습니다.
  + 사용 가능한 단어 조각들은 문자열 형태이며, 모든 단어 조각의 길이는 1 이상 5 이하입니다.
  + t는 완성해야 하는 문자열이며 길이는 1 이상 20,000 이하입니다.
  + 모든 문자열은 알파벳 소문자로만 이루어져 있습니다.

###### 입출력 예
|strs|t|result|
|:---|:---|:---|
|["ba","na","n","a"]|"banana"|3|
|["app","ap","p","l","e","ple","pp"]|"apple"|2|
|["ba","an","nan","ban","n"]|"banana"|-1|

###### 입출력 예 설명
입출력 예 #1  
문제의 예시와 같습니다.

입출력 예 #2
"ap" 1개, "ple" 1개의 총 2개로 "apple"을 만들 수 있으므로 필요한 단어 개수의 최솟값은 2를 return 합니다.

입출력 예 #3
주어진 단어로는 "banana"를 만들 수 없으므로 -1을 return 합니다.

###### 코드 : [Word_Puzzle.cpp](./Word_Puzzle.cpp)
<br>

## 2. 도둑질
도둑이 어느 마을을 털 계획을 하고 있습니다. 이 마을의 모든 집들은 아래 그림과 같이 동그랗게 배치되어 있습니다.  
<img src="https://user-images.githubusercontent.com/39071652/128127241-f7f1c09a-c501-4005-8f5f-41b85c22c8da.png" width="150">  
각 집들은 서로 인접한 집들과 방범장치가 연결되어 있기 때문에 인접한 두 집을 털면 경보가 울립니다. 각 집에 있는 돈이 담긴 배열 money가 주어질 때, 도둑이 훔칠 수 있는 돈의 최댓값을 return 하도록 solution 함수를 작성하세요.

###### 제한사항
  + 이 마을에 있는 집은 3개 이상 1,000,000개 이하입니다.
  + money 배열의 각 원소는 0 이상 1,000 이하인 정수입니다.

###### 입출력 예
|money|return|
|:---|:---|
|[1,2,3,1]|4|

###### 코드 : [Thieving.cpp](./Thieving.cpp)
<br>

## 3. 3 x n 타일링
가로 길이가 2이고 세로의 길이가 1인 직사각형 모양의 타일이 있습니다. 이 직사각형 타일을 이용하여 세로의 길이가 3이고 가로의 길이가 n인 바닥을 가득 채우려고 합니다. 타일을 채울 때는 다음과 같이 2가지 방법이 있습니다.  
  - 타일을 가로로 배치 하는 경우
  - 타일을 세로로 배치 하는 경우

예를 들어서 n이 8인 직사각형은 다음과 같이 채울 수 있습니다.  
<img src="https://user-images.githubusercontent.com/39071652/131137286-3a88d7ca-2fa6-4b94-9fe3-7b3752ed5513.png" width="300">  
직사각형의 가로의 길이 n이 매개변수로 주어질 때, 이 직사각형을 채우는 방법의 수를 return 하는 solution 함수를 완성해주세요.  

###### 제한사항
  - 가로의 길이 n은 5,000 이하의 자연수 입니다.
  - 경우의 수가 많아질 수 있으므로, 경우의 수를 1,000,000,007으로 나눈 나머지를 return 해주세요.

###### 입출력 예
|n|result|
|:---|:---|
|4|11|

###### 입출력 예 설명
입출력 예 #1  
다음과 같이 11가지 방법이 있다.  
<img src="https://user-images.githubusercontent.com/39071652/131137644-66a1f374-bd3f-4a70-ae77-248c3c9af2b9.png" width="600">  

###### 코드 : [3xn_Tiling.cpp](./3xn_Tiling.cpp)
<br>

## 4. 최적의 행렬 곱셈
크기가 a by b인 행렬과 크기가 b by c 인 행렬이 있을 때, 두 행렬을 곱하기 위해서는 총 a x b x c 번 곱셈해야합니다. 예를 들어서 크기가 5 by 3인 행렬과 크기가 3 by 2인 행렬을 곱할때는 총 5 x 3 x 2 = 30번의 곱하기 연산을 해야 합니다.  
행렬이 2개일 때는 연산 횟수가 일정 하지만, 행렬의 개수가 3개 이상일 때는 연산의 순서에 따라서 곱하기 연산의 횟수가 바뀔 수 있습니다. 예를 들어서 크기가 5 by 3인 행렬 A, 크기가 3 by 10인 행렬 B, 크기가 10 by 6인 행렬 C가 있을 때, 순서대로 A와 B를 먼저 곱하고, 그 결과에 C를 곱하면 A와 B행렬을 곱할 때 150번을, AB 에 C를 곱할 때 300번을 연산을 해서 총 450번의 곱하기 연산을 합니다. 하지만, B와 C를 먼저 곱한 다음 A 와 BC를 곱하면 180 + 90 = 270번 만에 연산이 끝납니다.  
각 행렬의 크기 matrix_sizes 가 매개변수로 주어 질 때, 모든 행렬을 곱하기 위한 최소 곱셈 연산의 수를 return하는 solution 함수를 완성해 주세요.  

###### 제한 사항
  - 행렬의 개수는 3이상 200이하의 자연수입니다.
  - 각 행렬의 행과 열의 크기는 200이하의 자연수 입니다.
  - 계산을 할 수 없는 행렬은 입력으로 주어지지 않습니다.

###### 입출력 예
|matrix_sizes|result|
|:---|:---|
|[[5,3],[3,10],[10,6]]|270|

###### 입출력 예 설명
입출력 예 #1  
문제의 예시와 같습니다. 

###### 코드 : [Optimal_Matrix_Multiplication.cpp](./Optimal_Matrix_Multiplication.cpp)
<br>

### 기타
###### 2019 KAKAO BLIND RECRUITMENT
## 1. 무지의 먹방 라이브
평소 식욕이 왕성한 무지는 자신의 재능을 뽐내고 싶어 졌고 고민 끝에 카카오 TV 라이브로 방송을 하기로 마음먹었다. 그냥 먹방을 하면 다른 방송과 차별성이 없기 때문에 무지는 아래와 같이 독특한 방식을 생각해냈다.  
회전판에 먹어야 할 N 개의 음식이 있다. 각 음식에는 1부터 N까지 번호가 붙어있으며, 각 음식을 섭취하는데 일정 시간이 소요된다.무지는 다음과 같은 방법으로 음식을 섭취한다.  
  + 무지는 1번 음식부터 먹기 시작하여, 회전판은 번호가 증가하는 순서대로 음식을 무지 앞으로 가져다 놓는다.
  + 마지막 번호의 음식을 섭취한 후에는 회전판에 의해 다시 1번 음식이 무지 앞으로 온다.
  + 무지는 음식 하나를 1초 동안 섭취한 후 남은 음식은 그대로 두고, 다음 음식을 섭취한다.
    - 다음 음식이란, 아직 남은 음식 중 다음으로 섭취해야 할 가장 가까운 번호의 음식을 말한다.
  + 회전판이 다음 음식을 무지 앞으로 가져오는데 걸리는 시간은 없다고 가정한다.

무지가 먹방을 시작한 지 K 초 후에 네트워크 장애로 인해 방송이 잠시 중단되었다. 무지는 네트워크 정상화 후 다시 방송을 이어갈 때, 몇 번 음식부터 섭취해야 하는지를 알고자 한다. 각 음식을 모두 먹는데 필요한 시간이 담겨있는 배열 food_times, 네트워크 장애가 발생한 시간 K 초가 매개변수로 주어질 때 몇 번 음식부터 다시 섭취하면 되는지 return 하도록 solution 함수를 완성하라.  

###### 제한사항
  + food_times는 각 음식을 모두 먹는데 필요한 시간이 음식의 번호 순서대로 들어있는 배열이다.
  + k 는 방송이 중단된 시간을 나타낸다.
  + 만약 더 섭취해야 할 음식이 없다면 **-1**을 반환하면 된다.

###### 정확성 테스트 제한 사항
  + food_times의 길이는 **1** 이상 **2,000** 이하이다.
  + food_times의 원소는 **1** 이상 **1,000** 이하의 자연수이다.
  + k는 **1** 이상 **2,000,000** 이하의 자연수이다.

###### 효율성 테스트 제한 사항
  + food_times의 길이는 **1** 이상 **200,000** 이하이다.
  + food_times의 원소는 **1** 이상 **1,000,000** 이하의 자연수이다.
  + k는 **1** 이상 **2 x 10^13** 이하의 자연수이다.

###### 입출력 예
|food_times|k|result|
|:---|:---|:---|
|[3,1,2]|5|1|

###### 입출력 예 설명
입출력 예 #1  
  + 0~1초 동안 1번 음식을 섭취한다. 남은 시간은 [2,1,2] 이다.
  + 1~2초 동안 2번 음식을 섭취한다. 남은 시간은 [2,0,2] 이다.
  + 2~3초 동안 3번 음식을 섭취한다. 남은 시간은 [2,0,1] 이다.
  + 3~4초 동안 1번 음식을 섭취한다. 남은 시간은 [1,0,1] 이다.
  + 4~5초 동안 (2번 음식은 다 먹었으므로) 3번 음식을 섭취한다. 남은 시간은 [1,0,0] 이다.
  + 5초에서 네트워크 장애가 발생했다. 1번 음식을 섭취해야 할 때 중단되었으므로, 장애 복구 후에 1번 음식부터 다시 먹기 시작하면 된다.

###### 코드 : [Muzi's_Mukbang_Live.cpp](./Muzi's_Mukbang_Live.cpp)
<br>

###### 2019 카카오 개발자 겨울 인턴십
## 2. 호텔 방 배정
"스노우타운"에서 호텔을 운영하고 있는 "스카피"는 호텔에 투숙하려는 고객들에게 방을 배정하려 합니다. 호텔에는 방이 총 k개 있으며, 각각의 방은 1번부터 k번까지 번호로 구분하고 있습니다. 처음에는 모든 방이 비어 있으며 "스카피"는 다음과 같은 규칙에 따라 고객에게 방을 배정하려고 합니다.  
  1. 한 번에 한 명씩 신청한 순서대로 방을 배정합니다.
  2. 고객은 투숙하기 원하는 방 번호를 제출합니다.
  3. 고객이 원하는 방이 비어 있다면 즉시 배정합니다.
  4. 고객이 원하는 방이 이미 배정되어 있으면 원하는 방보다 번호가 크면서 비어있는 방 중 가장 번호가 작은 방을 배정합니다.

예를 들어, 방이 총 10개이고, 고객들이 원하는 방 번호가 순서대로 [1,3,4,1,3,1] 일 경우 다음과 같이 방을 배정받게 됩니다.
|원하는 방 번호|배정된 방 번호|
|:---|:---|
|1|1|
|3|3|
|4|4|
|1|2|
|3|5|
|1|6|

전체 방 개수 k와 고객들이 원하는 방 번호가 순서대로 들어있는 배열 room_number가 매개변수로 주어질 때, 각 고객에게 배정되는 방 번호를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.

###### 제한사항
  - k는 1 이상 10^12 이하인 자연수입니다.
  - room_number 배열의 크기는 1 이상 200,000 이하입니다.
  - romm_number 배열 각 원소들의 값은 1 이상 k 이하인 자연수입니다.
  - room_number 배열은 모든 고객이 방을 배정받을 수 있는 경우만 입력으로 주어집니다.
    - 예를 들어, k = 5, room_number = [5,5] 와 같은 경우는 방을 배정받지 못하는 고객이 발생하므로 이런 경우는 입력으로 주어지지 않습니다.

###### 입출력 예
|k|room_number|result|
|:---|:---|:---|
|10|[1,3,4,1,3,1]|[1,3,4,2,5,6]|

###### 입출력 예에 대한 설명
입출력 예 #1  
문제의 예시와 같습니다.  
첫 번째 ~ 세 번째 고객까지는 원하는 방이 비어 있으므로 즉시 배정받을 수 있습니다. 네 번째 고객의 경우 1번 방을 배정받기를 원했는데, 1번 방은 빈 방이 아니므로, 1번 보다 번호가 크고 비어 있는 방 중에서 가장 번호가 작은 방을 배정해야 합니다. 1번 보다 번호가 크면서 비어있는 방은 [2번, 5번, 6번...] 방이며, 이중 가장 번호가 작은 방은 2번 방입니다. 따라서 네 번째 고객은 2번 방을 배정받습니다. 마찬가지로 5, 6번째 고객은 각각 5번, 6번 방을 배정받게 됩니다.

###### 코드 : [Hotel_Room_Assignment.cpp](./Hotel_Room_Assignment.cpp)
<br>

## 3. 올바른 괄호의 갯수
올바른 괄호란 (())나 ()와 같이 올바르게 모두 닫힌 괄호를 의미합니다. )(나 ())() 와 같은 괄호는 올바르지 않은 괄호가 됩니다. 괄호 쌍의 개수 n이 주어질 때, n개의 괄호 쌍으로 만들 수 있는 모든 가능한 괄호 문자열의 갯수를 반환하는 함수 solution을 완성해 주세요.  

###### 제한사항
  - 괄호 쌍의 개수 N : 1 ≤ n ≤ 14, N은 정수

###### 입출력 예
|n|result|
|:---|:---|
|2|2|
|3|5|

###### 입출력 예 설명
입출력 예 #1  
2개의 괄호쌍으로 [ <q>(())</q>, <q>()()</q> ]의 2가지를 만들 수 있습니다.  

입출력 예 #2  
2개의 괄호쌍으로 [ <q>((()))</q>, <q>(()())</q>, <q>(())()</q>, <q>()(())</q>, <q>()()()</q> ]의 5가지를 만들 수 있습니다.  

###### 코드 : [Number_of_Correct_Parentheses.cpp](./Number_of_Correct_Parentheses.cpp)
<br>

###### Summer/Winter Coding(~2018)
## 4. 쿠키 구입
과자를 바구니 단위로 파는 가게가 있습니다. 이 가게는 1번부터 N번까지 차례로 번호가 붙은 바구니 N개가 일렬로 나열해 놨습니다.  
철수는 두 아들에게 줄 과자를 사려합니다. 첫째 아들에게는 l번 바구니부터 m번 바구니까지, 둘째 아들에게는 m+1번 바구니부터 r번 바구니까지를 주려합니다. 단, 두 아들이 받을 과자 수는 같아야 합니다(1 <= l <= m, m+1 <= r <= N). 즉, A[i] 를 i번 바구니에 들어있는 과자 수라고 했을 때, **A[l]+..+A[m] = A[m+1]+..+A[r]** 를 만족해야 합니다.  
각 바구니 안에 들은 과자 수가 차례로 들은 배열 cookie가 주어질 때, 조건에 맞게 과자를 살 경우 한 명의 아들에게 줄 수 있는 가장 많은 과자 수를 return 하는 solution 함수를 완성해주세요. (단, 조건에 맞게 과자를 구매할 수 없다면 0을 return 합니다)  

###### 제한사항
  - cookie의 길이는 1 이상 2,000 이하입니다.
  - cookie의 각각의 원소는 1 이상 500 이하인 자연수입니다.

###### 입출력 예
|cookie|result|
|:---|:---|
|[1,1,2,3]|3|
|[1,2,4,5]|0|

###### 입출력 예 설명
입출력 예 #1  
첫째 아들에게 2, 3번 바구니를, 둘째 아들에게 4번 바구니를 사주면 두 아들은 각각 과자 3개를 받습니다.  

입출력 예 #2
주어진 조건에 맞게 과자를 살 방법이 없습니다.  

###### 코드 : [Buy_Cookies.cpp](./Buy_Cookies.cpp)
<br>

## 5. 숫자 블록
그렙시에는 0으로 된 도로에 숫자 블록을 설치하기로 하였습니다. 숫자 블록의 규칙은 다음과 같습니다.  
블록의 번호가 n 일 때, 가장 처음 블록은 n * 2번째 위치에 설치합니다. 그다음은 n * 3, 그다음은 n * 4, ...로 진행합니다.만약 기존에 블록이 깔려있는 자리라면 그 블록을빼고 새로운 블록으로 집어넣습니다.  
예를 들어 1번 블록은 2,3,4,5, ... 인 위치에 우선 설치합니다. 그다음 2번 블록은 4,6,8,10, ... 인 위치에 설치하고, 3번 블록은 6,9,12... 인 위치에 설치합니다. 이렇게 3번 블록까지 설치하고 나면 첫 10개의 블록은 0, 1, 1, 2, 1, 3, 1, 2, 3, 2이됩니다.  
그렙시는 길이가 1,000,000,000인 도로에 1번 블록부터 시작하여 10,000,000번 블록까지 위의 규칙으로 모두 놓았습니다. 그렙시의 시장님은 특정 구간의 어떤 블록이 깔려 있는지 알고 싶습니다. 구간을 나타내는 두 수 begin, end 가 매개변수로 주어 질 때, 그 구간에 깔려 있는 블록의 숫자 배열(리스트)을 return하는 solution 함수를 완성해 주세요.  

###### 제한사항
  - begin, end 는 1 이상 1,000,000,000이하의 자연수 이고, begin는 항상 end보다 작습니다.
  - end - begin 의 값은 항상 10,000을 넘지 않습니다.

###### 입출력 예
|begin|end|result|
|:---|:---|:---|
|1|10|[0, 1, 1, 2, 1, 3, 1, 4, 3, 5]|

###### 입출력 예 설명
입출력 예 #1  
다음과 같이 블럭이 깔리게 됩니다.  
<img src="https://user-images.githubusercontent.com/39071652/131685611-276a24d1-99e2-44e7-8ad1-8b1098fe1d25.png" width="350">  

###### 코드 : [Number_Block.cpp](./Number_Block.cpp)
<br>

------
<br>

##### 문제출처 및 이용 사이트
> 프로그래머스 [Programmers](https://programmers.co.kr)  

##### 사용 프로그램
> Visual Studio 2019  
