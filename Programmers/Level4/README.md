Level 4 코딩테스트 연습

목표
> Level 3 & 4  
> Visual Studio 2019 사용

### 목차
- 이분탐색
  - [1. 징검다리](#1-징검다리)
- 깊이/너비 우선 탐색
  - [1. 지형 이동](#1-지형-이동)
- 동적계획법
  - [1. 단어 퍼즐](#1-단어-퍼즐)
  - [2. 도둑질](#2-도둑질)
- 기타
  - [1. 무지의 먹방 라이브](#1-무지의-먹방-)
<br>

# 문제
### 이분탐색 Binary Search
## 1. 징검다리
출발지점부터 distance만틈 떨어진 곳에 도착지점이 있습니다. 그리고 그 사이에는 바위들이 놓여있습니다. 바위 중 몇 개를 제거하려고 합니다. 예를 들어, 도착지점이 25만큼 떨어져 있고, 바위가 [2, 14, 11, 21, 17] 지점에 놓여있을 때 바위 2개를 제거하면 출발지점, 도착지점, 바위 간의 거리가 아래와 같습니다.  
|제거한 바위의 위치|각 바위 사이의 거리|거리의 최솟값|
|:---|:---|:---|
|[21,17]|[2,9,3,11]|2|
|[2,21]|[11,3,3,8]|3|
|[2,11]|[14,3,4,4]|3|
|[11,21]|[2,12,3,8]|2|
|[2,14]|[11,6,4,4]|4|

위에서 구한 거리의 최솟값 중에 가장 큰 값은 4입니다.  
출발지점부터 도착지점까지의 거리 distance, 바위들이 있는 위치를 담은 배열 rocks, 제거할 바위의 수 n이 매개변수로 주어질 때, 바위를 n개 제거한 뒤 각 지점 사이의 거리의 최솟값 중에 가장 큰 값을 return 하도록 solution 함수를 작성해주세요.  

###### 제한사항
  + 도착지점까지의 거리 distance는 1 이상 1,000,000,000 이하입니다.
  + 바위는 1개 이상 50,000개 이하가 있습니다.
  + n은 1 이상 *바위의 개수* 이하입니다.

###### 입출력 예
|distance|rocks|n|return|
|:---|:---|:---|:---|
|25|[2,14,11,21,17]|2|4|

###### 입출력 예 설명
문제에 나온 예와 같습니다.

###### 코드 : [Stepping_Stone.cpp](./Stepping_Stone.cpp)
<br>


### 깊이/너비 우선 탐색(Depth/Breadth First Search); DFS/BFS
###### Summer/Winter Coding(2019)
## 1. 지형 이동
N x N 크기인 정사각 격자 형태의 지형이 있습니다. 각 격자 칸의 1 x 1 크기이며, 숫자가 하나씩 적혀있습니다. 격자 칸에 적힌 숫자는 그 칸의 높이를 나타냅니다.  
이 지형의 아무 칸에서나 출발해 모든 칸을 방문하는 탐험을 떠나려 합니다. 칸을 이동할 때는 상, 하, 좌, 우로 한 칸씩 이동할 수 있는데, 현재 칸과 이동하려는 칸의 높이 차가 height 이하여야 합니다. 높이 차가 height 보다 많이 나는 경우에는 사다리를 설치해서 이동할 수 있습니다. 이때, 사다리를 설치하는데 두 격자 칸의 높이차만큼 비용이 듭니다. 따라서, 최대한 적은 비용이 들도록 사다리를 설치해서 모든 칸으로 이동 가능하도록 해야 합니다. 설치할 수 있는 사다리 개수에 제한은 없으며, 설치한 사다리는 철거하지 않습니다.  
각 격자칸의 높이가 담긴 2차원 배열 land와 이동 가능한 최대 높이차 height가 매개변수로 주어질 때, 모든 칸을 방문하기 위해 필요한 사다리 설치 비용의 최솟값을 return 하도록 solution 함수를 완성해주세요.

###### 제한사항
  + land는 N x N 크기인 2차원 배열입니다.
  + land의 최소 크기는 4 x 4, 최대 크기는 300 x 300입니다.
  + land의 원소는 각 격자 칸의 높이를 나타냅니다.
  + 격자 칸의 높이는 1 이상 10,000 이하인 자연수입니다.
  + height는 1 이상 10,000 이하인 자연수입니다.

###### 입출력 예
|land|height|result|
|:---|:---|:---|
|[[1,4,8,10],[5,5,5,5],[10,10,10,10],[10,10,10,20]]|3|15|
|[[10,11,10,11],[2,21,20,10],[1,20,21,11],[2,1,2,1]]|1|18|

###### 입출력 예 설명
입출력 예 #1  
각 칸의 높이는 다음과 같으며, 높이차가 3 이하인 경우 사다리 없이 이동이 가능합니다.  
<img src="https://user-images.githubusercontent.com/39071652/127616083-4dcfcf44-aa1e-41af-ae20-78c4350fe856.png" width="200">  
위 그림에서 사다리를 이용하지 않고 이동 가능한 범위는 같은 색으로 칠해져 있습니다. 예를 들어 (1행 2열) 높이 4인 칸에서 (1행 3열) 높이 8인 칸으로 직접 이동할 수는 없지만, 높이가 5인 칸을 이용하면 사다리를 사용하지 않고 이동할 수 있습니다. 따라서 다음과 같이 사다리 두 개만 설치하면 모든 칸을 방문할 수 있고 최소 비용은 15가 됩니다.  
  + 높이 5인 칸 높이 10인 칸 : 비용 5
  + 높이 10인 칸 높이 20인 칸 : 비용 10

입출력 예 #2  
각 칸의 높이는 다음과 같으며, 높이차가 1 이하인 경우 사다리 없이 이동이 가능합니다.  
<img src="https://user-images.githubusercontent.com/39071652/127616126-2aecd8d9-34b1-4679-89c9-090c846e4022.png" width="200">  
위 그림과 같이 (2행 1열) → (1행 1열), (1행 2열) → (2행 2열) 두 곳에 사다리를 설치하면 설치비용이 18로 최소가 됩니다.

###### 코드 : [Terrain_Movement.cpp](./Terrain_Movement.cpp)
<br>


### 동적계획법(Dynamic Programming); DP
###### 2017 팁스타운
## 1. 단어 퍼즐
단어 퍼즐은 주어진 단어 조각들을 이용해서 주어진 문장을 완성하는 퍼즐입니다. 이때, 주어진 각 단어 조각들은 각각 무한개씩 있다고 가정합니다. 예를 들어 주어진 단어 조각이 [“ba”, “na”, “n”, “a”]인 경우 "ba", "na", "n", "a" 단어 조각이 각각 무한개씩 있습니다. 이때, 만들어야 하는 문장이 “banana”라면 “ba”, “na”, “n”, “a”의 4개를 사용하여 문장을 완성할 수 있지만, “ba”, “na”, “na”의 3개만을 사용해도 “banana”를 완성할 수 있습니다. 사용 가능한 단어 조각들을 담고 있는 배열 strs와 완성해야 하는 문자열 t가 매개변수로 주어질 때, 주어진 문장을 완성하기 위해 사용해야 하는 단어조각 개수의 최솟값을 return 하도록 solution 함수를 완성해 주세요. 만약 주어진 문장을 완성하는 것이 불가능하면 -1을 return 하세요.

###### 제한사항
  + strs는 사용 가능한 단어 조각들이 들어있는 배열로, 길이는 1 이상 100 이하입니다.
  + strs의 각 원소는 사용 가능한 단어조각들이 중복 없이 들어있습니다.
  + 사용 가능한 단어 조각들은 문자열 형태이며, 모든 단어 조각의 길이는 1 이상 5 이하입니다.
  + t는 완성해야 하는 문자열이며 길이는 1 이상 20,000 이하입니다.
  + 모든 문자열은 알파벳 소문자로만 이루어져 있습니다.

###### 입출력 예
|strs|t|result|
|:---|:---|:---|
|["ba","na","n","a"]|"banana"|3|
|["app","ap","p","l","e","ple","pp"]|"apple"|2|
|["ba","an","nan","ban","n"]|"banana"|-1|

###### 입출력 예 설명
입출력 예 #1  
문제의 예시와 같습니다.

입출력 예 #2
"ap" 1개, "ple" 1개의 총 2개로 "apple"을 만들 수 있으므로 필요한 단어 개수의 최솟값은 2를 return 합니다.

입출력 예 #3
주어진 단어로는 "banana"를 만들 수 없으므로 -1을 return 합니다.

###### 코드 : [Word_Puzzle.cpp](./Word_Puzzle.cpp)
<br>

## 2. 도둑질
도둑이 어느 마을을 털 계획을 하고 있습니다. 이 마을의 모든 집들은 아래 그림과 같이 동그랗게 배치되어 있습니다.  
<img src="https://user-images.githubusercontent.com/39071652/128127241-f7f1c09a-c501-4005-8f5f-41b85c22c8da.png" width="150">  
각 집들은 서로 인접한 집들과 방범장치가 연결되어 있기 때문에 인접한 두 집을 털면 경보가 울립니다. 각 집에 있는 돈이 담긴 배열 money가 주어질 때, 도둑이 훔칠 수 있는 돈의 최댓값을 return 하도록 solution 함수를 작성하세요.

###### 제한사항
  + 이 마을에 있는 집은 3개 이상 1,000,000개 이하입니다.
  + money 배열의 각 원소는 0 이상 1,000 이하인 정수입니다.

###### 입출력 예
|money|return|
|:---|:---|
|[1,2,3,1]|4|

###### 코드 : [Thieving.cpp](./Thieving.cpp)
<br>

### 기타
###### 2019 KAKAO BLIND RECRUITMENT
## 1. 무지의 먹방 라이브
평소 식욕이 왕성한 무지는 자신의 재능을 뽐내고 싶어 졌고 고민 끝에 카카오 TV 라이브로 방송을 하기로 마음먹었다. 그냥 먹방을 하면 다른 방송과 차별성이 없기 때문에 무지는 아래와 같이 독특한 방식을 생각해냈다.  
회전판에 먹어야 할 N 개의 음식이 있다. 각 음식에는 1부터 N까지 번호가 붙어있으며, 각 음식을 섭취하는데 일정 시간이 소요된다.무지는 다음과 같은 방법으로 음식을 섭취한다.  
  + 무지는 1번 음식부터 먹기 시작하여, 회전판은 번호가 증가하는 순서대로 음식을 무지 앞으로 가져다 놓는다.
  + 마지막 번호의 음식을 섭취한 후에는 회전판에 의해 다시 1번 음식이 무지 앞으로 온다.
  + 무지는 음식 하나를 1초 동안 섭취한 후 남은 음식은 그대로 두고, 다음 음식을 섭취한다.
    - 다음 음식이란, 아직 남은 음식 중 다음으로 섭취해야 할 가장 가까운 번호의 음식을 말한다.
  + 회전판이 다음 음식을 무지 앞으로 가져오는데 걸리는 시간은 없다고 가정한다.

무지가 먹방을 시작한 지 K 초 후에 네트워크 장애로 인해 방송이 잠시 중단되었다. 무지는 네트워크 정상화 후 다시 방송을 이어갈 때, 몇 번 음식부터 섭취해야 하는지를 알고자 한다. 각 음식을 모두 먹는데 필요한 시간이 담겨있는 배열 food_times, 네트워크 장애가 발생한 시간 K 초가 매개변수로 주어질 때 몇 번 음식부터 다시 섭취하면 되는지 return 하도록 solution 함수를 완성하라.  

###### 제한사항
  + food_times는 각 음식을 모두 먹는데 필요한 시간이 음식의 번호 순서대로 들어있는 배열이다.
  + k 는 방송이 중단된 시간을 나타낸다.
  + 만약 더 섭취해야 할 음식이 없다면 **-1**을 반환하면 된다.

###### 정확성 테스트 제한 사항
  + food_times의 길이는 **1** 이상 **2,000** 이하이다.
  + food_times의 원소는 **1** 이상 **1,000** 이하의 자연수이다.
  + k는 **1** 이상 **2,000,000** 이하의 자연수이다.

###### 효율성 테스트 제한 사항
  + food_times의 길이는 **1** 이상 **200,000** 이하이다.
  + food_times의 원소는 **1** 이상 **1,000,000** 이하의 자연수이다.
  + k는 **1** 이상 **2 x 10^13** 이하의 자연수이다.

###### 입출력 예
|food_times|k|result|
|:---|:---|:---|
|[3,1,2]|5|1|

###### 입출력 예 설명
입출력 예 #1  
  + 0~1초 동안 1번 음식을 섭취한다. 남은 시간은 [2,1,2] 이다.
  + 1~2초 동안 2번 음식을 섭취한다. 남은 시간은 [2,0,2] 이다.
  + 2~3초 동안 3번 음식을 섭취한다. 남은 시간은 [2,0,1] 이다.
  + 3~4초 동안 1번 음식을 섭취한다. 남은 시간은 [1,0,1] 이다.
  + 4~5초 동안 (2번 음식은 다 먹었으므로) 3번 음식을 섭취한다. 남은 시간은 [1,0,0] 이다.
  + 5초에서 네트워크 장애가 발생했다. 1번 음식을 섭취해야 할 때 중단되었으므로, 장애 복구 후에 1번 음식부터 다시 먹기 시작하면 된다.

###### 코드 : [Muzi's_Mukbang_Live.cpp](./Muzi's_Mukbang_Live.cpp)
<br>

------
<br>

##### 문제출처 및 이용 사이트
> 프로그래머스 [Programmers](https://programmers.co.kr)  

##### 사용 프로그램
> Visual Studio 2019  
