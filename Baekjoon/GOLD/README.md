백준 Gold 코딩 연습

목표  
> Gold  
> 알고리즘  
> 자료구조  
> Visual Studio 2019 사용  

### 목차
- Gold Ⅴ
  - [1025.](#1025-제곱수-찾기) 제곱수 찾기
  - [1068.](#1068-트리) 트리
  - [1188.](#1188-음식-평론가) 음식 평론가
- Gold Ⅳ
  - [1062.](#1062-가르침) 가르침
  - [1261.](#1261-알고스팟) 알고스팟
  - [1339.](#1339-단어-수학) 단어 수학
  - [1351.](#1351-무한-수열) 무한 수열
  - [1354.](#1354-무한-수열-2) 무한 수열 2
  - [1504.](#1504-특정한-최단-경로) 특정한 최단 경로
- Gold Ⅲ
  - [1005.](#1005-acm-craft) ACM Craft
  - [1167.](#1167-트리의-지름) 트리의 지름
  - [1238.](#1238-파티) 파티
<br>

# 문제
### Gold Ⅴ
### 1025. 제곱수 찾기
N행 M열의 표 A가 있고, 표의 각 칸에는 숫자가 하나씩 적혀있다. 연두는 서로 다른 1개 이상의 칸을 선택하려고 하는데, 행의 번호가 선택한 순서대로 등차수열을 이루고 있어야 하고, 열의 번호도 선택한 순서대로 등차수열을 이루고 있어야 한다. 이렇게 선택한 칸에 적힌 수를 순서대로 이어붙이면 정수를 하나 만들 수 있다.  
연두가 만들 수 있는 정수 중에서 가장 큰 완전 제곱수를 구해보자. 완전 제곱수란 어떤 정수를 제곱한 수이다.  

###### [입력]
첫째 줄에 N, M이 주어진다. 둘째 줄부터 N개의 줄에는 표에 적힌 숫자가 1번 행부터 N번 행까지 순서대로 한 줄에 한 행씩 주어진다. 한 행에 적힌 숫자는 1번 열부터 M번 열까지 순서대로 주어지고, 공백없이 모두 붙여져 있다.  

###### [출력]
첫째 줄에 연두가 만들 수 있는 가장 큰 완전 제곱수를 출력한다. 만약, 완전 제곱수를 만들 수 없는 경우에는 -1을 출력한다.  

###### [제한]
  - 1 ≤ N, M ≤ 9
  - 표에 적힌 숫자는 0보다 크거나 같고, 9보다 작거나 같다.

###### [예제 입력/출력]
|예제 입력 1|예제 출력 1|
|:---|:---|
|2 3</br>123</br>456|64|

만들 수 있는 세자리 수는 123, 321, 456, 654이다. 이 중 완전 제곱수는 없기 때문에 정답은 64가 된다.  

|예제 입력 2|예제 출력 2|
|:---|:---|
|5 5</br>00000</br>00000</br>00200</br>00000</br>00000|0|

0은 완전 제곱수이고, 입력으로 주어진 표에서 만들 수 있는 가장 큰 완전 제곱수이다.  

|예제 입력 3|예제 출력 3|
|:---|:---|
|6 7</br>3791178</br>1283252</br>4103617</br>8233494</br>8725572</br>2937261|320356|

모든 i번 행의 i번 열에 적힌 수를 이어붙이면 320356을 만들 수 있고, 이 수는 566^2 = 320356 이다.  

###### 알고리즘 분류
> 브루트포스 알고리즘  

###### 코드 [Find_the_Square_Number.cpp](./Find_the_Square_Number.cpp)
<br>

### 1068. 트리
트리에서 리프 노드란, 자식의 개수가 0인 노드를 말한다. 트리가 주어졌을 때, 노드 하나를 지울 것이다. 그 때, 남은 트리에서 리프 노드의 개수를 구하는 프로그램을 작성하시오. 노드를 지우면 그 노드와 노드의 모든 자손이 트리에서 제거된다.  
예를 들어, 다음과 같은 트리가 있다고 하자.  
<img src="https://user-images.githubusercontent.com/39071652/138470420-f82a080e-ed0f-4baf-8f5d-c17ed90454e4.png" width="150">  
현재 리프 노드의 개수는 3개이다. (초록색 색칠된 노드) 이때, 1번을 지우면, 다음과 같이 변한다. 검정색으로 색칠된 노드가 트리에서 제거된 노드이다.  
<img src="https://user-images.githubusercontent.com/39071652/138470479-f83d269d-b680-44e2-a91f-e5cd30ef416f.png" width="150">  
이제 리프 노드의 개수는 1개이다.  

###### [입력]
첫째 줄에 트리의 노드의 개수 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 0번 노드부터 N-1번 노드까지, 각 노드의 부모가 주어진다. 만약 부모가 없다면 (루트) -1이 주어진다. 셋째 줄에는 지울 노드의 번호가 주어진다.  

###### [출력]
첫째 줄에 입력으로 주어진 트리에서 입력으로 주어진 노드를 지웠을 때, 리프 노드의 개수를 출력한다.

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|5</br>-1 0 0 1 1</br>2|2|

|예제 입력2|예제 출력2|
|:---|:---|
|5</br>-1 0 0 1 1</br>1|1|

|예제 입력3|예제 출력3|
|:---|:---|
|5</br>-1 0 0 1 1</br>0|0|

|예제 입력1|예제 출력1|
|:---|:---|
|9</br>-1 0 0 2 2 4 4 6 6</br>4|2|

###### 알고리즘 분류
> 트리  
> 깊이 우선 탐색  

###### 코드 [Tree.cpp](./Tree.cpp)
<br>

### 1188. 음식 평론가
선영이의 직업은 소시지 요리사이다. 소시지를 팔기 전에 음식 평론가 M명을 모아서 맛을 테스트해보려고 한다. 선영이는 동일한 소시지를 총 N개를 준비했다. 이 소시지를 모든 평론가들이 같은 양을 받게 소시지를 자르려고 한다. 이때, 소시지를 자르는 횟수를 최소로 하려고 한다.  
예를 들어, 소시지가 2개, 평론가가 6명있는 경우를 생각해보자. 이때, 각 소시지를 세 조각으로 만든 다음, 각 평론가에게 한 조각씩 주면 된다. 이 경우에 소시지는 총 네 번 자르게 된다. 다른 경우로 소시지가 3개, 평론가가 4명 있는 경우를 생각해보자. 이때는 각 소시지의 크기를 3:1로 잘라서 큰 조각을 평론가에게 하나씩 주고, 남은 조각을 평론가에게 주면 모두 동일한 양을 받게 된다.  
소시지의 수와 평론가의 수가 주어졌을 때, 모든 평론가에게 같은 양의 소시지를 주기 위해 필요한 칼질의 수를 구하는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 소시지의 수 N과 평론가의 수 M이 주어진다. (1 ≤ N, M ≤ 100)  

###### [출력]
첫째 줄에 모든 평론가에게 동일한 양을 주기 위해 필요한 칼질 횟수의 최솟값을 출력한다.   

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|2 6|4|

|예제 입력2|예제 출력2|
|:---|:---|
|3 4|3|

|예제 입력3|예제 출력3|
|:---|:---|
|6 2|0|

###### 코드 [Food_Critic.cpp](./Food_Critic.cpp)
<br>

### Gold Ⅳ
### 1062. 가르침
남극에 사는 김지민 선생님은 학생들이 되도록이면 많은 단어를 읽을 수 있도록 하려고 한다. 그러나 지구온난화로 인해 얼음이 녹아서 곧 학교가 무너지기 때문에, 김지민은 K개의 글자를 가르칠 시간 밖에 없다. 김지민이 가르치고 난 후에는, 학생들은 그 K개의 글자로만 이루어진 단어만을 읽을 수 있다. 김지민은 어떤 K개의 글자를 가르쳐야 학생들이 읽을 수 있는 단어의 개수가 최대가 되는지 고민에 빠졌다.  
남극언어의 모든 단어는 "anta"로 시작되고, "tica"로 끝난다. 남극언어에 단어는 N개 밖에 없다고 가정한다. 학생들이 읽을 수 있는 단어의 최댓값을 구하는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 단어의 개수 N과 K가 주어진다. N은 50보다 작거나 같은 자연수이고, K는 26보다 작거나 같은 자연수 또는 0이다. 둘째 줄부터 N개의 줄에 남극 언어의 단어가 주어진다. 단어는 영어 소문자로만 이루어져 있고, 길이가 8보다 크거나 같고, 15보다 작거나 같다. 모든 단어는 중복되지 않는다.  

###### [출력]
첫째 줄에 김지민이 K개의 글자를 가르칠 때, 학생들이 읽을 수 있는 단어 개수의 최댓값을 출력한다.  

###### [에제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|3 6</br>antarctica</br>antahelltica</br>antacartica|2|

|예제 입력2|예제 출력2|
|:---|:---|
|2 3</br>antaxxxxxxxtica</br>antarctica|0|

|예제 입력3|예제 출력3|
|:---|:---|
|9 8</br>antabtica</br>antaxtica</br>antadtica</br>antaetica</br>antaftica</br>antagtica</br>antahtica</br>antajtica</br>antaktica|3|

###### 알고리즘 분류
> 백트래킹  

###### 코드 [Teaching.cpp](./Teaching.cpp)
<br>

### 1261. 알고스팟
알고스팟 운영진이 모두 미로에 갇혔다. 미로는 N*M 크기이며, 총 1*1크기의 방으로 이루어져 있다. 미로는 빈 방 또는 벽으로 이루어져 있고, 빈 방은 자유롭게 다닐 수 있지만, 벽은 부수지 않으면 이동할 수 없다.  
알고스팟 운영진은 여러명이지만, 항상 모두 같은 방에 있어야 한다. 즉, 여러 명이 다른 방에 있을 수는 없다. 어떤 방에서 이동할 수 있는 방은 상하좌우로 인접한 빈 방이다. 즉, 현재 운영진이 (x, y)에 있을 때, 이동할 수 있는 방은 (x+1, y), (x, y+1), (x-1, y), (x, y-1) 이다. 단, 미로의 밖으로 이동 할 수는 없다. 벽은 평소에는 이동할 수 없지만, 알고스팟의 무기 AOJ를 이용해 벽을 부수어 버릴 수 있다. 벽을 부수면, 빈 방과 동일한 방으로 변한다.  
만약 이 문제가 알고스팟에 있다면, 운영진들은 궁극의 무기 sudo를 이용해 벽을 한 번에 다 없애버릴 수 있지만, 안타깝게도 이 문제는 Baekjoon Online Judge에 수록되어 있기 때문에, sudo를 사용할 수 없다. 현재 (1, 1)에 있는 알고스팟 운영진이 (N, M)으로 이동하려면 벽을 최소 몇 개 부수어야 하는지 구하는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 미로의 크기를 나타내는 가로 크기 M, 세로 크기 N (1 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 미로의 상태를 나타내는 숫자 0과 1이 주어진다. 0은 빈 방을 의미하고, 1은 벽을 의미한다. (1, 1)과 (N, M)은 항상 뚫려있다.  
###### [출력]
첫째 줄에 알고스팟 운영진이 (N, M)으로 이동하기 위해 벽을 최소 몇 개 부수어야 하는지 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|3 3</br>011</br>111</br>110|3|

|예제 입력2|예제 입력2|
|:---|:---|
|4 2</br>0001</br>1000|0|

|예제 입력3|예제 입력3|
|:---|:---|
|6 6</br>001111</br>010000</br>001111</br>110001</br>011010</br>100010|2|

###### 알고리즘 분류
> 다익스트라  
> 너비 우선 탐색

###### 코드 [Algospot.cpp](./Algospot.cpp)
<br>

### 1339. 단어 수학
민식이는 수학학원에서 단어 수학 문제를 푸는 숙제를 받았다. 단어 수학 문제는 N개의 단어로 이루어져 있으며, 각 단어는 알파벳 대문자로만 이루어져 있다. 이때, 각 알파벳 대문자를 0부터 9까지의 숫자 중 하나로 바꿔서 N개의 수를 합하는 문제이다. 같은 알파벳은 같은 숫자로 바꿔야 하며, 두 개 이상의 알파벳이 같은 숫자로 바뀌어지면 안 된다.  
예를 들어, GCF + ACDEB를 계산한다고 할 때, A = 9, B = 4, C = 8, D = 6, E = 5, F = 3, G = 7로 결정한다면, 두 수의 합은 99437이 되어서 최대가 될 것이다.  
N개의 단어가 주어졌을 때, 그 수의 합을 최대로 만드는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 단어의 개수 N(1 ≤ N ≤ 10)이 주어진다. 둘째 줄부터 N개의 줄에 단어가 한 줄에 하나씩 주어진다. 단어는 알파벳 대문자로만 이루어져있다. 모든 단어에 포함되어 있는 알파벳은 최대 10개이고, 수의 최대 길이는 8이다. 서로 다른 문자는 서로 다른 숫자를 나타낸다.  

###### [출력]
첫째 줄에 주어진 단어의 합의 최댓값을 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|2</br>AAA</br>AAA|1998|

|예제 입력2|예제 출력2|
|:---|:---|
|2</br>GCF</br>ACDEB|99437|

|예제 입력3|예제 출력3|
|:---|:---|
|10</br>A</br>B</br>C</br>D</br>E</br>F</br>G</br>H</br>I</br>J|45|

|예제 입력4|예제 출력4|
|:---|:---|
|2</br>AB</br>BA|187|

###### 알고리즘 분류
> 그리디 알고리즘  

###### 코드 [Word_Math.cpp](./Word_Math.cpp)
<br>

### 1351. 무한 수열
무한 수열 A는 다음과 같다.  
  - A_0 = 1
  - A_i = A_⌊i/P⌋ + A_⌊i/Q⌋ (i ≥ 1)

N, P와 Q가 주어질 때, A_N을 구하는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 3개의 정수 N, P, Q가 주어진다.  

###### [출력]
첫째 줄에 A_N을 출력한다.  

###### [제한]
  - 0 ≤ N ≤ 10^12
  - 2 ≤ P, Q ≤ 10^9

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|7 2 3|7|

|예제 입력2|예제 출력2|
|:---|:---|
|0 2 3|1|

|예제 입력3|예제 출력3|
|:---|:---|
|10000000 3 3|32768|

|예제 입력4|예제 출력4|
|:---|:---|
|256 2 4|89|

|예제 입력5|예제 출력5|
|:---|:---|
|1 1000000 1000000|2|

###### 알고리즘 분류
> 다이나믹 프로그래밍  

###### 코드 [Infinite_Sequence.cpp](./Infinite_Sequence.cpp)
<br>

### 1354. 무한 수열 2
무한 수열 A는 다음과 같다.  
  - A_i = 1 (i ≤ 0)
  - A_i = A_⌊i/P⌋-X + A_⌊i/Q⌋-Y (i ≥ 1)

N, P, Q, X, Y가 주어질 때, A_N을 구하는 프로그램을 작성하시오.

###### [입력]
첫째 줄에 5개의 정수 N, P, Q, X, Y가 주어진다.  

###### [출력]
첫째 줄에 A_N을 출력한다.  

###### [제한]
  - 0 ≤ N ≤ 10^13
  - 2 ≤ P, Q ≤ 10^9
  - 0 ≤ X, Y ≤ 10^9

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|10000000 2 3 10000000 10000000|2|

|예제 입력2|예제 출력2|
|:---|:---|
|12 2 3 1 0|8|

|예제 입력3|예제 출력3|
|:---|:---|
|0 2 2 0 0|1|

|예제 입력4|예제 출력4|
|:---|:---|
|123 45 67 8 9|2|

###### 알고리즘 분류
> 다이나믹 프로그래밍  

###### 코드 [Infinite_Sequence_2.cpp](./Infinite_Sequence_2.cpp)
<br>

### 1504. 특정한 최단 경로
방향성이 없는 그래프가 주어진다. 세준이는 1번 정점에서 N번 정점으로 최단 거리로 이동하려고 한다. 또한 세준이는 두 가지 조건을 만족하면서 이동하는 특정한 최단 경로를 구하고 싶은데, 그것은 바로 임의로 주어진 두 정점은 반드시 통과해야 한다는 것이다. 세준이는 한번 이동했던 정점은 물론, 한번 이동했던 간선도 다시 이동할 수 있다. 하지만 반드시 최단 경로로 이동해야 한다는 사실에 주의하라. 1번 정점에서 N번 정점으로 이동할 때, 주어진 두 정점을 반드시 거치면서 최단 경로로 이동하는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 정점의 개수 N과 간선의 개수 E가 주어진다. (2 ≤ N ≤ 800, 0 ≤ E ≤ 200,000) 둘째 줄부터 E개의 줄에 걸쳐서 세 개의 정수 a, b, c가 주어지는데, a번 정점에서 b번 정점까지 양방향 길이 존재하며, 그 거리가 c라는 뜻이다. (1 ≤ c ≤ 1,000) 다음 줄에는 반드시 거쳐야 하는 두 개의 서로 다른 정점 번호 v1과 v2가 주어진다. (v1 ≠ v2, v1 ≠ N, v2 ≠ 1)  

###### [출력]
첫째 줄에 두 개의 정점을 지나는 최단 경로의 길이를 출력한다. 그러한 경로가 없을 때에는 -1을 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|4 6</br>1 2 3</br>2 3 3</br>3 4 1</br>1 3 5</br>2 4 5</br>1 4 4</br>2 3|9|

###### 알고리즘 분류
> 다익스트라  

###### 코드 [Specific_Shortest_path.cpp](./Specific_Shortest_path.cpp)
<br>

### Gold Ⅲ
### 1005. ACM Craft
서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft (Association of Construction Manager Craft)가 발매되었다.  
이 게임은 지금까지 나온 게임들과는 다르게 ACM크래프트는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져 있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.  
<img src="https://user-images.githubusercontent.com/39071652/138850962-f58e9113-4859-4b93-9fb4-3e3e747ea502.png" width="250">  
위의 예시를 보자.  
이번 게임에서는 다음과 같이 건설 순서 규칙이 주어졌다. 1번 건물의 건설이 완료된다면 2번과 3번의 건설을 시작할수 있다. (동시에 진행이 가능하다) 그리고 4번 건물을 짓기 위해서는 2번과 3번 건물이 모두 건설 완료되어야지만 4번건물의 건설을 시작할수 있다. 따라서 4번건물의 건설을 완료하기 위해서는 우선 처음 1번 건물을 건설하는데 10초가 소요된다. 그리고 2번 건물과 3번 건물을 동시에 건설하기 시작하면 2번은 1초뒤에 건설이 완료되지만 아직 3번 건물이 완료되지 않았으므로 4번 건물을 건설할 수 없다. 3번 건물이 완성되고 나면 그때 4번 건물을 지을수 있으므로 4번 건물이 완성되기까지는 총 120초가 소요된다.  
프로게이머 최백준은 애인과의 데이트 비용을 마련하기 위해 서강대학교배 ACM크래프트 대회에 참가했다! 최백준은 화려한 컨트롤 실력을 가지고 있기 때문에 모든 경기에서 특정 건물만 짓는다면 무조건 게임에서 이길 수 있다. 그러나 매 게임마다 특정건물을 짓기 위한 순서가 달라지므로 최백준은 좌절하고 있었다. 백준이를 위해 특정건물을 가장 빨리 지을 때까지 걸리는 최소시간을 알아내는 프로그램을 작성해주자.  

###### [입력]
첫째 줄에는 테스트케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 주어진다. 첫째 줄에 건물의 개수 N과 건물간의 건설순서 규칙의 총 개수 K이 주어진다. (건물의 번호는 1번부터 N번까지 존재한다)  
둘째 줄에는 각 건물당 건설에 걸리는 시간 D1, D2, ..., DN이 공백을 사이로 주어진다. 셋째 줄부터 K+2줄까지 건설순서 X Y가 주어진다. (이는 건물 X를 지은 다음에 건물 Y를 짓는 것이 가능하다는 의미이다)  
마지막 줄에는 백준이가 승리하기 위해 건설해야 할 건물의 번호 W가 주어진다.  

###### [출력]
건물 W를 건설완료 하는데 드는 최소 시간을 출력한다. 편의상 건물을 짓는 명령을 내리는 데는 시간이 소요되지 않는다고 가정한다. 건설순서는 모든 건물이 건설 가능하도록 주어진다.  

###### [제한]
  - 2 ≤ N ≤ 1000
  - 1 ≤ K ≤ 100,000
  - 1 ≤ X, Y, W ≤ N
  - 0 ≤ Di ≤ 100,000, Di는 정수

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|2</br>4 4</br>10 1 100 10</br>1 2</br>1 3</br>2 4</br>3 4</br>4</br>8 8</br>10 20 1 5 8 7 1 43</br>1 2</br>1 3</br>2 4</br>2 5</br>3 6</br>5 7</br>6 7</br>7 8</br>7|120</br>39|

|예제 입력2|예제 출력2|
|:---|:---|
|5</br>3 2</br> 1 2 3</br>3 2</br>2 1</br>1</br>4 3</br>5 5 5 5</br>1 2</br>1 3</br>2 3</br>4</br>5 10</br>100000 99999 99997 99994 99990</br>4 5</br>3 5</br>3 4</br>2 5</br>2 4</br>2 3</br>1 5</br>1 4</br>1 3</br>1 2</br>4</br>4 3</br>1 1 1 1</br>1 2</br>3 2</br>1 4</br>4</br>7 8</br>0 0 0 0 0 0 0</br>1 2</br>1 3</br>2 4</br>3 4</br>4 5</br>4 6</br>5 7</br>6 7</br>7|6</br>5</br>399990</br>2</br>0|

###### 알고리즘 분류
> 다이나믹 프로그래밍  
> 위상 정렬  

###### 코드 [ACM_Craft.cpp](./ACM_Craft.cpp)
<br>

### 1167. 트리의 지름
트리의 지름이란, 트리에서 임의의 두 점 사이의 거리 중 가장 긴 것을 말한다. 트리의 지름을 구하는 프로그램을 작성하시오.  

###### [입력]
트리가 입력으로 주어진다. 먼저 첫 번째 줄에서는 트리의 정점의 개수 V가 주어지고 (2 ≤ V ≤ 100,000)둘째 줄부터 V개의 줄에 걸쳐 간선의 정보가 다음과 같이 주어진다. 정점 번호는 1부터 V까지 매겨져 있다.  
먼저 정점 번호가 주어지고, 이어서 연결된 간선의 정보를 의미하는 정수가 두 개씩 주어지는데, 하나는 정점번호, 다른 하나는 그 정점까지의 거리이다. 예를 들어 네 번째 줄의 경우 정점 3은 정점 1과 거리가 2인 간선으로 연결되어 있고, 정점 4와는 거리가 3인 간선으로 연결되어 있는 것을 보여준다. 각 줄의 마지막에는 -1이 입력으로 주어진다. 주어지는 거리는 모두 10,000 이하의 자연수이다.  

###### [출력]
첫째 줄에 트리의 지름을 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|5</br>1 3 2 -1</br>2 4 4 -1</br>3 1 2 4 3 -1</br>4 2 4 3 3 5 6 -1</br>5 4 6 -1|11|

###### 알고리즘 분류
> 트리  
> 깊이 우선 탐색  

###### 코드 [Diameter_of_the_Tree.cpp](./Diameter_of_the_Tree.cpp)
<br>

### 1238. 파티
N개의 숫자로 구분된 각각의 마을에 한 명의 학생이 살고 있다. 어느 날 이 N명의 학생이 X (1 ≤ X ≤ N)번 마을에 모여서 파티를 벌이기로 했다. 이 마을 사이에는 총 M개의 단방향 도로들이 있고 i번째 길을 지나는데 Ti(1 ≤ Ti ≤ 100)의 시간을 소비한다. 각각의 학생들은 파티에 참석하기 위해 걸어가서 다시 그들의 마을로 돌아와야 한다. 하지만 이 학생들은 워낙 게을러서 최단 시간에 오고 가기를 원한다. 이 도로들은 단방향이기 때문에 아마 그들이 오고 가는 길이 다를지도 모른다. N명의 학생들 중 오고 가는데 가장 많은 시간을 소비하는 학생은 누구일지 구하여라.  

###### [입력]
첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 10,000), X가 공백으로 구분되어 입력된다. 두 번째 줄부터 M+1번째 줄까지 i번째 도로의 시작점, 끝점, 그리고 이 도로를 지나는데 필요한 소요시간 Ti가 들어온다. 시작점과 끝점이 같은 도로는 없으며, 시작점과 한 도시 A에서 다른 도시 B로 가는 도로의 개수는 최대 1개이다.  
모든 학생들은 집에서 X에 갈수 있고, X에서 집으로 돌아올 수 있는 데이터만 입력으로 주어진다.  

###### [출력]
첫 번째 줄에 N명의 학생들 중 오고 가는데 가장 오래 걸리는 학생의 소요시간을 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|4 8 2</br>1 2 4</br>1 3 2</br>1 4 7</br>2 1 1</br>2 3 5</br>3 1 2</br>3 4 4</br>4 2 3|10|

###### 알고리즘 분류
> 다익스트라  

###### 코드 [Party.cpp](./Party.cpp)
<br>

------
<br>

##### 문제출처 및 이용 사이트
> 백준 [Baekjoon](https://www.acmicpc.net)  

##### 사용 프로그램
> Visual Studio 2019  
