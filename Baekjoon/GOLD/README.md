백준 Gold 코딩 연습

목표  
> Gold  
> 알고리즘  
> 자료구조  
> Visual Studio 2019 사용  

### 목차
- Gold Ⅴ
  - [1025.](#1025-제곱수-찾기) 제곱수 찾기
  - [1068.](#1068-트리) 트리
  - [1188.](#1188-음식-평론가) 음식 평론가
  - [1374.](#1374-강의실) 강의실
  - [1662.](#1662-압축) 압축
  - [2015.](#2015-수들의-합-4) 수들의 합 4
  - [2023.](#2023-신기한-소수) 신기한 소수
  - [2170.](#2170-선-긋기) 선 긋기
  - [2470.](#2470-두-용액) 두 용액
- Gold Ⅳ
  - [1062.](#1062-가르침) 가르침
  - [1261.](#1261-알고스팟) 알고스팟
  - [1322.](#1322-X와-K) X와 K
  - [1339.](#1339-단어-수학) 단어 수학
  - [1351.](#1351-무한-수열) 무한 수열
  - [1354.](#1354-무한-수열-2) 무한 수열 2
  - [1504.](#1504-특정한-최단-경로) 특정한 최단 경로
  - [1715.](#1715-카드-정렬하기) 카드 정렬하기
  - [1719.](#1719-택배) 택배
  - [2206.](#2206-벽-부수고-이동하기) 벽 부수고 이동하기
- Gold Ⅲ
  - [1005.](#1005-acm-craft) ACM Craft
  - [1167.](#1167-트리의-지름) 트리의 지름
  - [1238.](#1238-파티) 파티
  - [1377.](#1377-버블-소트) 버블 소트
  - [1507.](#1507-궁금한-민호) 궁금한 민호
  - [1516.](#1516-게임-개발) 게임 개발
  - [1613.](#1613-역사) 역사
- Gold Ⅱ
  - [1007.](#1007-벡터-매칭) 벡터 매칭
  - [1103.](#1103-게임) 게임
  - [1111.](#1111-iq-test) IQ Test
  - [1202.](#1202-보석-도둑) 보석 도둑
  - [1300.](#1300-k번째-수) K번째 수
<br>

# 문제
### Gold Ⅴ
### 1025. 제곱수 찾기
N행 M열의 표 A가 있고, 표의 각 칸에는 숫자가 하나씩 적혀있다. 연두는 서로 다른 1개 이상의 칸을 선택하려고 하는데, 행의 번호가 선택한 순서대로 등차수열을 이루고 있어야 하고, 열의 번호도 선택한 순서대로 등차수열을 이루고 있어야 한다. 이렇게 선택한 칸에 적힌 수를 순서대로 이어붙이면 정수를 하나 만들 수 있다.  
연두가 만들 수 있는 정수 중에서 가장 큰 완전 제곱수를 구해보자. 완전 제곱수란 어떤 정수를 제곱한 수이다.  

###### [입력]
첫째 줄에 N, M이 주어진다. 둘째 줄부터 N개의 줄에는 표에 적힌 숫자가 1번 행부터 N번 행까지 순서대로 한 줄에 한 행씩 주어진다. 한 행에 적힌 숫자는 1번 열부터 M번 열까지 순서대로 주어지고, 공백없이 모두 붙여져 있다.  

###### [출력]
첫째 줄에 연두가 만들 수 있는 가장 큰 완전 제곱수를 출력한다. 만약, 완전 제곱수를 만들 수 없는 경우에는 -1을 출력한다.  

###### [제한]
  - 1 ≤ N, M ≤ 9
  - 표에 적힌 숫자는 0보다 크거나 같고, 9보다 작거나 같다.

###### [예제 입력/출력]
|예제 입력 1|예제 출력 1|
|:---|:---|
|2 3</br>123</br>456|64|

만들 수 있는 세자리 수는 123, 321, 456, 654이다. 이 중 완전 제곱수는 없기 때문에 정답은 64가 된다.  

|예제 입력 2|예제 출력 2|
|:---|:---|
|5 5</br>00000</br>00000</br>00200</br>00000</br>00000|0|

0은 완전 제곱수이고, 입력으로 주어진 표에서 만들 수 있는 가장 큰 완전 제곱수이다.  

|예제 입력 3|예제 출력 3|
|:---|:---|
|6 7</br>3791178</br>1283252</br>4103617</br>8233494</br>8725572</br>2937261|320356|

모든 i번 행의 i번 열에 적힌 수를 이어붙이면 320356을 만들 수 있고, 이 수는 566^2 = 320356 이다.  

###### 알고리즘 분류
> 브루트포스 알고리즘  

###### 코드 [Find_the_Square_Number.cpp](./Find_the_Square_Number.cpp)
<br>

### 1068. 트리
트리에서 리프 노드란, 자식의 개수가 0인 노드를 말한다. 트리가 주어졌을 때, 노드 하나를 지울 것이다. 그 때, 남은 트리에서 리프 노드의 개수를 구하는 프로그램을 작성하시오. 노드를 지우면 그 노드와 노드의 모든 자손이 트리에서 제거된다.  
예를 들어, 다음과 같은 트리가 있다고 하자.  
<img src="https://user-images.githubusercontent.com/39071652/138470420-f82a080e-ed0f-4baf-8f5d-c17ed90454e4.png" width="150">  
현재 리프 노드의 개수는 3개이다. (초록색 색칠된 노드) 이때, 1번을 지우면, 다음과 같이 변한다. 검정색으로 색칠된 노드가 트리에서 제거된 노드이다.  
<img src="https://user-images.githubusercontent.com/39071652/138470479-f83d269d-b680-44e2-a91f-e5cd30ef416f.png" width="150">  
이제 리프 노드의 개수는 1개이다.  

###### [입력]
첫째 줄에 트리의 노드의 개수 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 0번 노드부터 N-1번 노드까지, 각 노드의 부모가 주어진다. 만약 부모가 없다면 (루트) -1이 주어진다. 셋째 줄에는 지울 노드의 번호가 주어진다.  

###### [출력]
첫째 줄에 입력으로 주어진 트리에서 입력으로 주어진 노드를 지웠을 때, 리프 노드의 개수를 출력한다.

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|5</br>-1 0 0 1 1</br>2|2|

|예제 입력2|예제 출력2|
|:---|:---|
|5</br>-1 0 0 1 1</br>1|1|

|예제 입력3|예제 출력3|
|:---|:---|
|5</br>-1 0 0 1 1</br>0|0|

|예제 입력1|예제 출력1|
|:---|:---|
|9</br>-1 0 0 2 2 4 4 6 6</br>4|2|

###### 알고리즘 분류
> 트리  
> 깊이 우선 탐색  

###### 코드 [Tree.cpp](./Tree.cpp)
<br>

### 1188. 음식 평론가
선영이의 직업은 소시지 요리사이다. 소시지를 팔기 전에 음식 평론가 M명을 모아서 맛을 테스트해보려고 한다. 선영이는 동일한 소시지를 총 N개를 준비했다. 이 소시지를 모든 평론가들이 같은 양을 받게 소시지를 자르려고 한다. 이때, 소시지를 자르는 횟수를 최소로 하려고 한다.  
예를 들어, 소시지가 2개, 평론가가 6명있는 경우를 생각해보자. 이때, 각 소시지를 세 조각으로 만든 다음, 각 평론가에게 한 조각씩 주면 된다. 이 경우에 소시지는 총 네 번 자르게 된다. 다른 경우로 소시지가 3개, 평론가가 4명 있는 경우를 생각해보자. 이때는 각 소시지의 크기를 3:1로 잘라서 큰 조각을 평론가에게 하나씩 주고, 남은 조각을 평론가에게 주면 모두 동일한 양을 받게 된다.  
소시지의 수와 평론가의 수가 주어졌을 때, 모든 평론가에게 같은 양의 소시지를 주기 위해 필요한 칼질의 수를 구하는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 소시지의 수 N과 평론가의 수 M이 주어진다. (1 ≤ N, M ≤ 100)  

###### [출력]
첫째 줄에 모든 평론가에게 동일한 양을 주기 위해 필요한 칼질 횟수의 최솟값을 출력한다.   

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|2 6|4|

|예제 입력2|예제 출력2|
|:---|:---|
|3 4|3|

|예제 입력3|예제 출력3|
|:---|:---|
|6 2|0|

###### 코드 [Food_Critic.cpp](./Food_Critic.cpp)
<br>

### 1374. 강의실
N개의 강의가 있다. 우리는 모든 강의의 시작하는 시간과 끝나는 시간을 알고 있다. 이때, 우리는 최대한 적은 수의 강의실을 사용하여 모든 강의가 이루어지게 하고 싶다. 물론, 한 강의실에서는 동시에 2개 이상의 강의를 진행할 수 없고, 한 강의의 종료시간과 다른 강의의 시작시간이 겹치는 것은 상관없다. 필요한 최소 강의실의 수를 출력하는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 강의의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 각 줄마다 세 개의 정수가 주어지는데, 순서대로 강의 번호, 강의 시작 시간, 강의 종료 시간을 의미한다. 강의 번호는 1부터 N까지 붙어 있으며, 입력에서 꼭 순서대로 주어지지 않을 수 있으나 한 번씩만 주어진다. 강의 시작 시간과 강의 종료 시간은 0 이상 10억 이하의 정수이고, 시작 시간은 종료 시간보다 작다.  

###### [출력]
첫째 줄에 필요한 최소 강의실 개수를 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|8</br>6 15 21</br>7 20 25</br>1 3 8</br>3 2 14</br>3 6 27</br>2 7 13</br>4 12 18</br>5 6 20|5|

###### 알고리즘 분류
> 그리디 알고리즘

###### 코드 [Lecture_Room.cpp](./Lecture_Room.cpp)
<br>

### 1662. 압축
압축되지 않은 문자열 S가 주어졌을 때, 이 문자열중 어떤 부분 문자열은 K(Q)와 같이 압축 할 수 있다. K는 한자리 정수이고, Q는 0자리 이상의 문자열이다. 이 Q라는 문자열이 K번 반복된다는 뜻이다. 압축된 문자열이 주어졌을 때, 이 문자열을 다시 압축을 푸는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 압축된 문자열 S가 들어온다. S의 길이는 최대 50이다. 문자열은 (, ), 0-9사이의 숫자로만 들어온다.  

###### [출력]
첫째 줄에 압축되지 않은 문자열의 길이를 출력한다. 이 값은 2,147,473,647 보다 작거나 같다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|33(562(71(9)))|19|

|예제 입력2|예제 출력2|
|:---|:---|
|123|3|

|예제 입력3|예제 출력3|
|:---|:---|
|10342(76)|8|

|예제 입력4|예제 출력4|
|:---|:---|
|0(0)|0|

|예제 입력5|예제 출력5|
|:---|:---|
|1(1(1(1(1(1(1(0(1234567890))))))))|0|

|예제 입력6|예제 출력6|
|:---|:---|
|1()66(5)|7|

###### 알고리즘 분류
> 재귀  

###### 코드 [Compression.cpp](./Compression.cpp)
<br>

### 2015. 수들의 합 4
A[1], A[2], ..., A[N]의 N개의 정수가 저장되어 있는 배열이 있다. 이 배열 A의 부분합이란 1 ≤ i ≤ j ≤ N인 정수 i와 j에 대해 A[i]부터 A[j]까지의 합을 말한다. N과 A[1], A[2], ..., A[N]이 주어졌을 때, 이러한 N×(N+1)/2개의 부분합 중 합이 K인 것이 몇 개나 있는지를 구하는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 정수 N과 K가 주어진다. (1 ≤ N ≤ 200,000, |K| ≤ 2,000,000,000) N과 K 사이에는 빈칸이 하나 있다. 둘째 줄에는 배열 A를 이루는 N개의 정수가 빈 칸을 사이에 두고 A[1], A[2], ..., A[N]의 순서로 주어진다. 주어지는 정수의 절댓값은 10,000을 넘지 않는다.  

###### [출력]
첫째 줄에 합이 K인 부분합의 개수를 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|4 0</br>2 -2 2 -2|4|

|예제 입력2|예제 출력2|
|:---|:---|
|6 5</br>1 2 3 4 5 0|3|

###### 코드 [2015_Sum_of_Numbers_4.cpp](./2015_Sum_of_Numbers_4.cpp)
<br>

### 2023. 신기한 소수
수빈이가 세상에서 가장 좋아하는 것은 소수이고, 취미는 소수를 가지고 노는 것이다. 요즘 수빈이가 가장 관심있어 하는 소수는 7331이다. 7331은 소수인데, 신기하게도 733도 소수이고, 73도 소수이고, 7도 소수이다. 즉, 왼쪽부터 1자리, 2자리, 3자리, 4자리 수 모두 소수이다! 수빈이는 이런 숫자를 신기한 소수라고 이름 붙였다. 수빈이는 N자리의 숫자 중에서 어떤 수들이 신기한 소수인지 궁금해졌다. N이 주어졌을 때, 수빈이를 위해 N자리 신기한 소수를 모두 찾아보자.  

###### [입력]
첫째 줄에 N(1 ≤ N ≤ 8)이 주어진다.

###### [출력]
N자리 수 중에서 신기한 소수를 오름차순으로 정렬해서 한 줄에 하나씩 출력한다.

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|4|2333</br>2339</br>2393</br>2399</br>2939</br>3119</br>3137</br>3733</br>3739</br>3793</br>3797</br>5939</br>7193</br>7331</br>7333</br>7393|

###### 알고리즘 분류
> 백트래킹  

###### 코드 [2023.cpp](./2023.cpp)
<br>

### 2170. 선 긋기
매우 큰 도화지에 자를 대고 선을 그으려고 한다. 선을 그을 때에는 자의 한 점에서 다른 한 점까지 긋게 된다. 선을 그을 때에는 이미 선이 있는 위치에 겹쳐서 그릴 수도 있는데, 여러 번 그은 곳과 한 번 그은 곳의 차이를 구별할 수 없다고 하자. 이와 같은 식으로 선을 그었을 때, 그려진 선(들)의 총 길이를 구하는 프로그램을 작성하시오. 선이 여러 번 그려진 곳은 한 번씩만 계산한다.  

###### [입력]
첫째 줄에 선을 그은 횟수 N(1 ≤ N ≤ 1,000,000)이 주어진다. 다음 N개의 줄에는 선을 그을 때 선택한 두 점의 위치 x, y(-1,000,000,000 ≤ x < y ≤ 1,000,000,000)가 주어진다.  

###### [출력]
첫째 줄에 그은 선의 총 길이를 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|4</br>1 3</br>2 5</br>3 5</br>6 7|5|

###### 코드 [Draw_a_Line.cpp](./Draw_a_Line.cpp)
<br>

### 2470. 두 용액
KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다.  산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다. 같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다. 예를 들어, 주어진 용액들의 특성값이 [-2, 4, -99, -1, 98]인 경우에는 특성값이 -99인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액이 특성값이 0에 가장 가까운 용액이다. 참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다. 산성 용액과 알칼리성 용액의 특성값이 주어졌을 때, 이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에는 전체 용액의 수 N이 입력된다. N은 2 이상 100,000 이하이다. 둘째 줄에는 용액의 특성값을 나타내는 N개의 정수가 빈칸을 사이에 두고 주어진다. 이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하이다. N개의 용액들의 특성값은 모두 다르고, 산성 용액만으로나 알칼리성 용액만으로 입력이 주어지는 경우도 있을 수 있다.  

###### [출력]
첫째 줄에 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액의 특성값을 출력한다. 출력해야 하는 두 용액은 특성값의 오름차순으로 출력한다. 특성값이 0에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우에는 그 중 아무것이나 하나를 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|5</br>-2 4 99 -1 98|-99 98|

###### 알고리즘 분류
> 이분 탐색  

###### 코드 [2470_Two_Solutions.cpp](./2470_Two_Solutions.cpp)
<br>

### Gold Ⅳ
### 1062. 가르침
남극에 사는 김지민 선생님은 학생들이 되도록이면 많은 단어를 읽을 수 있도록 하려고 한다. 그러나 지구온난화로 인해 얼음이 녹아서 곧 학교가 무너지기 때문에, 김지민은 K개의 글자를 가르칠 시간 밖에 없다. 김지민이 가르치고 난 후에는, 학생들은 그 K개의 글자로만 이루어진 단어만을 읽을 수 있다. 김지민은 어떤 K개의 글자를 가르쳐야 학생들이 읽을 수 있는 단어의 개수가 최대가 되는지 고민에 빠졌다.  
남극언어의 모든 단어는 "anta"로 시작되고, "tica"로 끝난다. 남극언어에 단어는 N개 밖에 없다고 가정한다. 학생들이 읽을 수 있는 단어의 최댓값을 구하는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 단어의 개수 N과 K가 주어진다. N은 50보다 작거나 같은 자연수이고, K는 26보다 작거나 같은 자연수 또는 0이다. 둘째 줄부터 N개의 줄에 남극 언어의 단어가 주어진다. 단어는 영어 소문자로만 이루어져 있고, 길이가 8보다 크거나 같고, 15보다 작거나 같다. 모든 단어는 중복되지 않는다.  

###### [출력]
첫째 줄에 김지민이 K개의 글자를 가르칠 때, 학생들이 읽을 수 있는 단어 개수의 최댓값을 출력한다.  

###### [에제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|3 6</br>antarctica</br>antahelltica</br>antacartica|2|

|예제 입력2|예제 출력2|
|:---|:---|
|2 3</br>antaxxxxxxxtica</br>antarctica|0|

|예제 입력3|예제 출력3|
|:---|:---|
|9 8</br>antabtica</br>antaxtica</br>antadtica</br>antaetica</br>antaftica</br>antagtica</br>antahtica</br>antajtica</br>antaktica|3|

###### 알고리즘 분류
> 백트래킹  

###### 코드 [Teaching.cpp](./Teaching.cpp)
<br>

### 1261. 알고스팟
알고스팟 운영진이 모두 미로에 갇혔다. 미로는 N*M 크기이며, 총 1*1크기의 방으로 이루어져 있다. 미로는 빈 방 또는 벽으로 이루어져 있고, 빈 방은 자유롭게 다닐 수 있지만, 벽은 부수지 않으면 이동할 수 없다.  
알고스팟 운영진은 여러명이지만, 항상 모두 같은 방에 있어야 한다. 즉, 여러 명이 다른 방에 있을 수는 없다. 어떤 방에서 이동할 수 있는 방은 상하좌우로 인접한 빈 방이다. 즉, 현재 운영진이 (x, y)에 있을 때, 이동할 수 있는 방은 (x+1, y), (x, y+1), (x-1, y), (x, y-1) 이다. 단, 미로의 밖으로 이동 할 수는 없다. 벽은 평소에는 이동할 수 없지만, 알고스팟의 무기 AOJ를 이용해 벽을 부수어 버릴 수 있다. 벽을 부수면, 빈 방과 동일한 방으로 변한다.  
만약 이 문제가 알고스팟에 있다면, 운영진들은 궁극의 무기 sudo를 이용해 벽을 한 번에 다 없애버릴 수 있지만, 안타깝게도 이 문제는 Baekjoon Online Judge에 수록되어 있기 때문에, sudo를 사용할 수 없다. 현재 (1, 1)에 있는 알고스팟 운영진이 (N, M)으로 이동하려면 벽을 최소 몇 개 부수어야 하는지 구하는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 미로의 크기를 나타내는 가로 크기 M, 세로 크기 N (1 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 미로의 상태를 나타내는 숫자 0과 1이 주어진다. 0은 빈 방을 의미하고, 1은 벽을 의미한다. (1, 1)과 (N, M)은 항상 뚫려있다.  
###### [출력]
첫째 줄에 알고스팟 운영진이 (N, M)으로 이동하기 위해 벽을 최소 몇 개 부수어야 하는지 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|3 3</br>011</br>111</br>110|3|

|예제 입력2|예제 입력2|
|:---|:---|
|4 2</br>0001</br>1000|0|

|예제 입력3|예제 입력3|
|:---|:---|
|6 6</br>001111</br>010000</br>001111</br>110001</br>011010</br>100010|2|

###### 알고리즘 분류
> 다익스트라  
> 너비 우선 탐색

###### 코드 [Algospot.cpp](./Algospot.cpp)
<br>

### 1322. X와 K
두 자연수 X와 K가 주어진다. 그러면, 다음 식을 만족하는 K번째로 작은 자연수 Y를 찾아야 한다. X + Y = X | Y  
|는 비트 연산 OR이다.  

###### [입력]
첫째 줄에 X와 K가 주어진다. X와 K는 2,000,000,000보다 작거나 같은 자연수이다.  

###### [출력]
첫째 줄에 X + Y = X | Y를 만족하는 K번째 작은 Y를 출력한다. 정답은 2^31-1 보다 클 수도 있다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|5 1|2|

|예제 입력2|예제 출력2|
|:---|:---|
|5 5|18|

|예제 입력3|예제 출력3|
|:---|:---|
|10 3|5|

|예제 입력4|예제 출력4|
|:---|:---|
|1 1000000000|2000000000|

###### 코드 [1322_X_and_K.cpp](./1322_X_and_K.cpp)
<br>

### 1339. 단어 수학
민식이는 수학학원에서 단어 수학 문제를 푸는 숙제를 받았다. 단어 수학 문제는 N개의 단어로 이루어져 있으며, 각 단어는 알파벳 대문자로만 이루어져 있다. 이때, 각 알파벳 대문자를 0부터 9까지의 숫자 중 하나로 바꿔서 N개의 수를 합하는 문제이다. 같은 알파벳은 같은 숫자로 바꿔야 하며, 두 개 이상의 알파벳이 같은 숫자로 바뀌어지면 안 된다.  
예를 들어, GCF + ACDEB를 계산한다고 할 때, A = 9, B = 4, C = 8, D = 6, E = 5, F = 3, G = 7로 결정한다면, 두 수의 합은 99437이 되어서 최대가 될 것이다.  
N개의 단어가 주어졌을 때, 그 수의 합을 최대로 만드는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 단어의 개수 N(1 ≤ N ≤ 10)이 주어진다. 둘째 줄부터 N개의 줄에 단어가 한 줄에 하나씩 주어진다. 단어는 알파벳 대문자로만 이루어져있다. 모든 단어에 포함되어 있는 알파벳은 최대 10개이고, 수의 최대 길이는 8이다. 서로 다른 문자는 서로 다른 숫자를 나타낸다.  

###### [출력]
첫째 줄에 주어진 단어의 합의 최댓값을 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|2</br>AAA</br>AAA|1998|

|예제 입력2|예제 출력2|
|:---|:---|
|2</br>GCF</br>ACDEB|99437|

|예제 입력3|예제 출력3|
|:---|:---|
|10</br>A</br>B</br>C</br>D</br>E</br>F</br>G</br>H</br>I</br>J|45|

|예제 입력4|예제 출력4|
|:---|:---|
|2</br>AB</br>BA|187|

###### 알고리즘 분류
> 그리디 알고리즘  

###### 코드 [Word_Math.cpp](./Word_Math.cpp)
<br>

### 1351. 무한 수열
무한 수열 A는 다음과 같다.  
  - A_0 = 1
  - A_i = A_⌊i/P⌋ + A_⌊i/Q⌋ (i ≥ 1)

N, P와 Q가 주어질 때, A_N을 구하는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 3개의 정수 N, P, Q가 주어진다.  

###### [출력]
첫째 줄에 A_N을 출력한다.  

###### [제한]
  - 0 ≤ N ≤ 10^12
  - 2 ≤ P, Q ≤ 10^9

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|7 2 3|7|

|예제 입력2|예제 출력2|
|:---|:---|
|0 2 3|1|

|예제 입력3|예제 출력3|
|:---|:---|
|10000000 3 3|32768|

|예제 입력4|예제 출력4|
|:---|:---|
|256 2 4|89|

|예제 입력5|예제 출력5|
|:---|:---|
|1 1000000 1000000|2|

###### 알고리즘 분류
> 다이나믹 프로그래밍  

###### 코드 [Infinite_Sequence.cpp](./Infinite_Sequence.cpp)
<br>

### 1354. 무한 수열 2
무한 수열 A는 다음과 같다.  
  - A_i = 1 (i ≤ 0)
  - A_i = A_⌊i/P⌋-X + A_⌊i/Q⌋-Y (i ≥ 1)

N, P, Q, X, Y가 주어질 때, A_N을 구하는 프로그램을 작성하시오.

###### [입력]
첫째 줄에 5개의 정수 N, P, Q, X, Y가 주어진다.  

###### [출력]
첫째 줄에 A_N을 출력한다.  

###### [제한]
  - 0 ≤ N ≤ 10^13
  - 2 ≤ P, Q ≤ 10^9
  - 0 ≤ X, Y ≤ 10^9

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|10000000 2 3 10000000 10000000|2|

|예제 입력2|예제 출력2|
|:---|:---|
|12 2 3 1 0|8|

|예제 입력3|예제 출력3|
|:---|:---|
|0 2 2 0 0|1|

|예제 입력4|예제 출력4|
|:---|:---|
|123 45 67 8 9|2|

###### 알고리즘 분류
> 다이나믹 프로그래밍  

###### 코드 [Infinite_Sequence_2.cpp](./Infinite_Sequence_2.cpp)
<br>

### 1504. 특정한 최단 경로
방향성이 없는 그래프가 주어진다. 세준이는 1번 정점에서 N번 정점으로 최단 거리로 이동하려고 한다. 또한 세준이는 두 가지 조건을 만족하면서 이동하는 특정한 최단 경로를 구하고 싶은데, 그것은 바로 임의로 주어진 두 정점은 반드시 통과해야 한다는 것이다. 세준이는 한번 이동했던 정점은 물론, 한번 이동했던 간선도 다시 이동할 수 있다. 하지만 반드시 최단 경로로 이동해야 한다는 사실에 주의하라. 1번 정점에서 N번 정점으로 이동할 때, 주어진 두 정점을 반드시 거치면서 최단 경로로 이동하는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 정점의 개수 N과 간선의 개수 E가 주어진다. (2 ≤ N ≤ 800, 0 ≤ E ≤ 200,000) 둘째 줄부터 E개의 줄에 걸쳐서 세 개의 정수 a, b, c가 주어지는데, a번 정점에서 b번 정점까지 양방향 길이 존재하며, 그 거리가 c라는 뜻이다. (1 ≤ c ≤ 1,000) 다음 줄에는 반드시 거쳐야 하는 두 개의 서로 다른 정점 번호 v1과 v2가 주어진다. (v1 ≠ v2, v1 ≠ N, v2 ≠ 1)  

###### [출력]
첫째 줄에 두 개의 정점을 지나는 최단 경로의 길이를 출력한다. 그러한 경로가 없을 때에는 -1을 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|4 6</br>1 2 3</br>2 3 3</br>3 4 1</br>1 3 5</br>2 4 5</br>1 4 4</br>2 3|9|

###### 알고리즘 분류
> 다익스트라  

###### 코드 [Specific_Shortest_path.cpp](./Specific_Shortest_path.cpp)
<br>

### 1715. 카드 정렬하기
정렬된 두 묶음의 숫자 카드가 있다고 하자. 각 묶음의 카드의 수를 A, B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는 A+B 번의 비교를 해야 한다. 이를테면, 20장의 숫자 카드 묶음과 30장의 숫자 카드 묶음을 합치려면 50번의 비교가 필요하다. 매우 많은 숫자 카드 묶음이 책상 위에 놓여 있다. 이들을 두 묶음씩 골라 서로 합쳐나간다면, 고르는 순서에 따라서 비교 횟수가 매우 달라진다. 예를 들어 10장, 20장, 40장의 묶음이 있다면 10장과 20장을 합친 뒤, 합친 30장 묶음과 40장을 합친다면 (10 + 20) + (30 + 40) = 100번의 비교가 필요하다. 그러나 10장과 40장을 합친 뒤, 합친 50장 묶음과 20장을 합친다면 (10 + 40) + (50 + 20) = 120 번의 비교가 필요하므로 덜 효율적인 방법이다. N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소한 몇 번의 비교가 필요한지를 구하는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100,000) 이어서 N개의 줄에 걸쳐 숫자 카드 묶음의 각각의 크기가 주어진다. 숫자 카드 묶음의 크기는 1,000보다 작거나 같은 양의 정수이다.  

###### [출력]
첫째 줄에 최소 비교 횟수를 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|3</br>10</br>20</br>40|100|

###### 알고리즘 분류
> 그리디 알고리즘  
> 우선순위 큐

###### 코드 [1715_Sort_the_Cards.cpp](./1715_Sort_the_Cards.cpp)
<br>

### 1719. 택배
명우기업은 2008년부터 택배 사업을 새로이 시작하기로 하였다. 우선 택배 화물을 모아서 처리하는 집하장을 몇 개 마련했지만, 택배 화물이 각 집하장들 사이를 오갈 때 어떤 경로를 거쳐야 하는지 결정하지 못했다. 어떤 경로를 거칠지 정해서, 이를 경로표로 정리하는 것이 여러분이 할 일이다.  
<img src="https://user-images.githubusercontent.com/39071652/147410621-4c959acd-e52b-41d5-b154-fb5bb274b7de.png" width="300">  
예시된 그래프에서 굵게 표시된 1, 2, 3, 4, 5, 6은 집하장을 나타낸다. 정점간의 간선은 두 집하장간에 화물 이동이 가능함을 나타내며, 가중치는 이동에 걸리는 시간이다. 이로부터 얻어내야 하는 경로표는 다음과 같다.  
<img src="https://user-images.githubusercontent.com/39071652/147410626-54da138a-873e-4f29-9328-8f3c96905f11.png" width="300">  
경로표는 한 집하장에서 다른 집하장으로 최단경로로 화물을 이동시키기 위해 가장 먼저 거쳐야 하는 집하장을 나타낸 것이다. 예를 들어 4행 5열의 6은 4번 집하장에서 5번 집하장으로 최단 경로를 통해 가기 위해서는 제일 먼저 6번 집하장으로 이동해야 한다는 의미이다. 이와 같은 경로표를 구하는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 두 수 n과 m이 빈 칸을 사이에 두고 순서대로 주어진다. n은 집하장의 개수로 200이하의 자연수, m은 집하장간 경로의 개수로 10000이하의 자연수이다. 이어서 한 줄에 하나씩 집하장간 경로가 주어지는데, 두 집하장의 번호와 그 사이를 오가는데 필요한 시간이 순서대로 주어진다. 집하장의 번호들과 경로의 소요시간은 모두 1000이하의 자연수이다.  

###### [출력]
예시된 것과 같은 형식의 경로표를 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|6 10</br>1 2 2</br>1 3 1</br>2 4 5</br>2 5 3</br>2 6 7</br>3 4 4</br>3 5 6</br>3 6 7</br>4 6 4</br>5 6 2|- 2 3 3 2 2</br>1 - 1 4 5 5</br>1 1 - 4 5 6</br>3 2 3 - 6 6</br>2 2 3 6 - 6</br>5 5 3 4 5 -|

###### 알고리즘 분류
> 다익스트라
> 플로이드-와샬

###### 코드 [1719_Package.cpp](./1719_Package.cpp)
<br>

### 2206. 벽 부수고 이동하기
N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다. 만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 한 개 까지 부수고 이동하여도 된다. 한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다. 맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.  

###### [출력]
첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|6 4</br>0100</br>1110</br>1000</br>0000</br>0111</br>0000|15|

|예제 입력2|예제 출력2|
|:---|:---|
|4 4</br>0111</br>1111</br>1111</br>1110|-1|

###### 알고리즘 분류
> 너비 우선 탐색  

###### 코드 [2206_Break_the_wall_and_Move.cpp](./2206_Break_the_wall_and_Move.cpp)

### Gold Ⅲ
### 1005. ACM Craft
서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft (Association of Construction Manager Craft)가 발매되었다.  
이 게임은 지금까지 나온 게임들과는 다르게 ACM크래프트는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져 있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.  
<img src="https://user-images.githubusercontent.com/39071652/138850962-f58e9113-4859-4b93-9fb4-3e3e747ea502.png" width="250">  
위의 예시를 보자.  
이번 게임에서는 다음과 같이 건설 순서 규칙이 주어졌다. 1번 건물의 건설이 완료된다면 2번과 3번의 건설을 시작할수 있다. (동시에 진행이 가능하다) 그리고 4번 건물을 짓기 위해서는 2번과 3번 건물이 모두 건설 완료되어야지만 4번건물의 건설을 시작할수 있다. 따라서 4번건물의 건설을 완료하기 위해서는 우선 처음 1번 건물을 건설하는데 10초가 소요된다. 그리고 2번 건물과 3번 건물을 동시에 건설하기 시작하면 2번은 1초뒤에 건설이 완료되지만 아직 3번 건물이 완료되지 않았으므로 4번 건물을 건설할 수 없다. 3번 건물이 완성되고 나면 그때 4번 건물을 지을수 있으므로 4번 건물이 완성되기까지는 총 120초가 소요된다.  
프로게이머 최백준은 애인과의 데이트 비용을 마련하기 위해 서강대학교배 ACM크래프트 대회에 참가했다! 최백준은 화려한 컨트롤 실력을 가지고 있기 때문에 모든 경기에서 특정 건물만 짓는다면 무조건 게임에서 이길 수 있다. 그러나 매 게임마다 특정건물을 짓기 위한 순서가 달라지므로 최백준은 좌절하고 있었다. 백준이를 위해 특정건물을 가장 빨리 지을 때까지 걸리는 최소시간을 알아내는 프로그램을 작성해주자.  

###### [입력]
첫째 줄에는 테스트케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 주어진다. 첫째 줄에 건물의 개수 N과 건물간의 건설순서 규칙의 총 개수 K이 주어진다. (건물의 번호는 1번부터 N번까지 존재한다)  
둘째 줄에는 각 건물당 건설에 걸리는 시간 D1, D2, ..., DN이 공백을 사이로 주어진다. 셋째 줄부터 K+2줄까지 건설순서 X Y가 주어진다. (이는 건물 X를 지은 다음에 건물 Y를 짓는 것이 가능하다는 의미이다)  
마지막 줄에는 백준이가 승리하기 위해 건설해야 할 건물의 번호 W가 주어진다.  

###### [출력]
건물 W를 건설완료 하는데 드는 최소 시간을 출력한다. 편의상 건물을 짓는 명령을 내리는 데는 시간이 소요되지 않는다고 가정한다. 건설순서는 모든 건물이 건설 가능하도록 주어진다.  

###### [제한]
  - 2 ≤ N ≤ 1000
  - 1 ≤ K ≤ 100,000
  - 1 ≤ X, Y, W ≤ N
  - 0 ≤ Di ≤ 100,000, Di는 정수

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|2</br>4 4</br>10 1 100 10</br>1 2</br>1 3</br>2 4</br>3 4</br>4</br>8 8</br>10 20 1 5 8 7 1 43</br>1 2</br>1 3</br>2 4</br>2 5</br>3 6</br>5 7</br>6 7</br>7 8</br>7|120</br>39|

|예제 입력2|예제 출력2|
|:---|:---|
|5</br>3 2</br> 1 2 3</br>3 2</br>2 1</br>1</br>4 3</br>5 5 5 5</br>1 2</br>1 3</br>2 3</br>4</br>5 10</br>100000 99999 99997 99994 99990</br>4 5</br>3 5</br>3 4</br>2 5</br>2 4</br>2 3</br>1 5</br>1 4</br>1 3</br>1 2</br>4</br>4 3</br>1 1 1 1</br>1 2</br>3 2</br>1 4</br>4</br>7 8</br>0 0 0 0 0 0 0</br>1 2</br>1 3</br>2 4</br>3 4</br>4 5</br>4 6</br>5 7</br>6 7</br>7|6</br>5</br>399990</br>2</br>0|

###### 알고리즘 분류
> 다이나믹 프로그래밍  
> 위상 정렬  

###### 코드 [ACM_Craft.cpp](./ACM_Craft.cpp)
<br>

### 1167. 트리의 지름
트리의 지름이란, 트리에서 임의의 두 점 사이의 거리 중 가장 긴 것을 말한다. 트리의 지름을 구하는 프로그램을 작성하시오.  

###### [입력]
트리가 입력으로 주어진다. 먼저 첫 번째 줄에서는 트리의 정점의 개수 V가 주어지고 (2 ≤ V ≤ 100,000)둘째 줄부터 V개의 줄에 걸쳐 간선의 정보가 다음과 같이 주어진다. 정점 번호는 1부터 V까지 매겨져 있다.  
먼저 정점 번호가 주어지고, 이어서 연결된 간선의 정보를 의미하는 정수가 두 개씩 주어지는데, 하나는 정점번호, 다른 하나는 그 정점까지의 거리이다. 예를 들어 네 번째 줄의 경우 정점 3은 정점 1과 거리가 2인 간선으로 연결되어 있고, 정점 4와는 거리가 3인 간선으로 연결되어 있는 것을 보여준다. 각 줄의 마지막에는 -1이 입력으로 주어진다. 주어지는 거리는 모두 10,000 이하의 자연수이다.  

###### [출력]
첫째 줄에 트리의 지름을 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|5</br>1 3 2 -1</br>2 4 4 -1</br>3 1 2 4 3 -1</br>4 2 4 3 3 5 6 -1</br>5 4 6 -1|11|

###### 알고리즘 분류
> 트리  
> 깊이 우선 탐색  

###### 코드 [Diameter_of_the_Tree.cpp](./Diameter_of_the_Tree.cpp)
<br>

### 1238. 파티
N개의 숫자로 구분된 각각의 마을에 한 명의 학생이 살고 있다. 어느 날 이 N명의 학생이 X (1 ≤ X ≤ N)번 마을에 모여서 파티를 벌이기로 했다. 이 마을 사이에는 총 M개의 단방향 도로들이 있고 i번째 길을 지나는데 Ti(1 ≤ Ti ≤ 100)의 시간을 소비한다. 각각의 학생들은 파티에 참석하기 위해 걸어가서 다시 그들의 마을로 돌아와야 한다. 하지만 이 학생들은 워낙 게을러서 최단 시간에 오고 가기를 원한다. 이 도로들은 단방향이기 때문에 아마 그들이 오고 가는 길이 다를지도 모른다. N명의 학생들 중 오고 가는데 가장 많은 시간을 소비하는 학생은 누구일지 구하여라.  

###### [입력]
첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 10,000), X가 공백으로 구분되어 입력된다. 두 번째 줄부터 M+1번째 줄까지 i번째 도로의 시작점, 끝점, 그리고 이 도로를 지나는데 필요한 소요시간 Ti가 들어온다. 시작점과 끝점이 같은 도로는 없으며, 시작점과 한 도시 A에서 다른 도시 B로 가는 도로의 개수는 최대 1개이다.  
모든 학생들은 집에서 X에 갈수 있고, X에서 집으로 돌아올 수 있는 데이터만 입력으로 주어진다.  

###### [출력]
첫 번째 줄에 N명의 학생들 중 오고 가는데 가장 오래 걸리는 학생의 소요시간을 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|4 8 2</br>1 2 4</br>1 3 2</br>1 4 7</br>2 1 1</br>2 3 5</br>3 1 2</br>3 4 4</br>4 2 3|10|

###### 알고리즘 분류
> 다익스트라  

###### 코드 [Party.cpp](./Party.cpp)
<br>

### 1377. 버블 소트
버블 소트 알고리즘을 다음과 같이 C++로 작성했다.  
``` C++
bool changed = false;
for (int i=1; i<=N+1; i++) {
    changed = false;
    for (int j=1; j<=N-i; j++) {
        if (A[j] > A[j+1]) {
            changed = true;
            swap(A[j], A[j+1]);
        }
    }
    if (changed == false) {
        cout << i << '\n';
        break;
    }
}
```
위 소스에서 N은 배열의 크기이고, A는 정렬해야 하는 배열이다. 배열은 A[1]부터 사용한다. 위와 같은 소스를 실행시켰을 때, 어떤 값이 출력되는지 구해보자.  

###### [입력]
첫째 줄에 N이 주어진다. N은 500,000보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 A[1]부터 A[N]까지 하나씩 주어진다. A에 들어있는 수는 1,000,000보다 작거나 같은 자연수 또는 0이다.  

###### [출력]
정답을 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|5</br>10</br>1</br>5</br>2</br>3|3|

|예제 입력2|예제 출력2|
|:---|:---|
|5</br>1</br>3</br>5</br>7</br>9|1|

###### 코드 [1377_Bubble_Sort.cpp](./1377_Bubble_Sort.cpp)
<br>

### 1507. 궁금한 민호
강호는 N개의 도시로 이루어진 나라에 살고 있다. 각 도시는 M개의 도로로 연결되어 있으며, 각 도로를 지날 때 필요한 시간이 존재한다. 도로는 잘 연결되어 있기 때문에, 도시 A에서 B로 이동할 수 없는 경우는 존재하지 않는다. 도시 A에서 도시 B로 바로 갈 수 있는 도로가 있거나, 다른 도시를 거쳐서 갈 수 있을 때, 도시 A에서 B를 갈 수 있다고 한다. 강호는 모든 쌍의 도시에 대해서 최소 이동 시간을 구해놓았다. 민호는 이 표를 보고 원래 도로가 몇 개 있는지를 구해보려고 한다. 예를 들어, 예제의 경우에 모든 도시 사이에 강호가 구한 값을 가지는 도로가 존재한다고 해도 된다. 하지만, 이 도로의 개수는 최솟값이 아니다. 예를 들어, 도시 1-2, 2-3, 1-4, 3-4, 4-5, 3-5를 연결하는 도로만 있다고 가정해도, 강호가 구한 모든 쌍의 최솟값을 구할 수 있다. 이 경우 도로의 개수는 6개이고, 모든 도로의 시간의 합은 55이다. 모든 쌍의 도시 사이의 최소 이동 시간이 주어졌을 때, 이 나라에 존재할 수 있는 도로의 개수의 최솟값일 때, 모든 도로의 시간의 합을 구하는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 도시의 개수 N(1 ≤ N ≤ 20)이 주어진다. 둘째 줄부터 N개의 줄에 각각의 도시 사이에 이동하는데 필요한 시간이 주어진다. A에서 B로 가는 시간과 B에서 A로 가는 시간은 같다. 또, A와 B가 같은 경우에는 0이 주어지고, 그 외의 경우에 필요한 시간은 2500보다 작거나 같은 자연수이다.  

###### [출력]
첫째 줄에 도로 개수가 최소일 때, 모든 도로의 시간의 합을 출력한다. 불가능한 경우에는 -1을 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|5</br>0 3 15 2 6</br>6 0 9 8 12</br>15 9 0 16 18</br>2 8 16 0 4</br>6 12 18 4 0|55|

|예제 입력2|예제 출력2|
|:---|:---|
|3</br>0 2 2</br>2 0 2</br>2 2 0|6|

|예제 입력3|예제 출력3|
|:---|:---|
|8</br>0 1 6 17 26 13 7 16</br>1 0 5 16 25 12 7 15</br>6 5 0 21 21 8 12 11</br>17 16 21 0 41 28 23 31</br>26 25 21 41 0 13 32 10</br>13 12 8 28 13 0 19 3</br>7 7 12 23 32 19 0 22</br>16 15 11 31 10 3 22 0|69|

|예제 입력4|예제 출력4|
|:---|:---|
|3</br>0 1 3</br>1 0 1</br>3 1 0|-1|

###### 알고리즘 분류
> 플로이드-와샬  

###### 코드 [1507_Curious_Minho.cpp](1507_Curious_Minho.cpp)
<br>

### 1516. 게임 개발
숌 회사에서 이번에 새로운 전략 시뮬레이션 게임 세준 크래프트를 개발하기로 하였다. 핵심적인 부분은 개발이 끝난 상태고, 종족별 균형과 전체 게임 시간 등을 조절하는 부분만 남아 있었다. 게임 플레이에 들어가는 시간은 상황에 따라 다를 수 있기 때문에, 모든 건물을 짓는데 걸리는 최소의 시간을 이용하여 근사하기로 하였다. 물론, 어떤 건물을 짓기 위해서 다른 건물을 먼저 지어야 할 수도 있기 때문에 문제가 단순하지만은 않을 수도 있다. 예를 들면 스타크래프트에서 벙커를 짓기 위해서는 배럭을 먼저 지어야 하기 때문에, 배럭을 먼저 지은 뒤 벙커를 지어야 한다. 여러 개의 건물을 동시에 지을 수 있다. 편의상 자원은 무한히 많이 가지고 있고, 건물을 짓는 명령을 내리기까지는 시간이 걸리지 않는다고 가정하자.  

###### [입력]
첫째 줄에 건물의 종류 수 N(1 ≤ N ≤ 500)이 주어진다. 다음 N개의 줄에는 각 건물을 짓는데 걸리는 시간과 그 건물을 짓기 위해 먼저 지어져야 하는 건물들의 번호가 주어진다. 건물의 번호는 1부터 N까지로 하고, 각 줄은 -1로 끝난다고 하자. 각 건물을 짓는데 걸리는 시간은 100,000보다 작거나 같은 자연수이다. 모든 건물을 짓는 것이 가능한 입력만 주어진다.  

###### [출력]
N개의 각 건물이 완성되기까지 걸리는 최소 시간을 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|5</br>10 -1</br>10 1 -1</br>4 1 -1</br>4 3 1 -1</br>3 3 -1|10</br>20</br>14</br>18</br>17|

###### 코드 [1516_Game_Development.cpp](./1516_Game_Development.cpp)
<br>

### 1613. 역사
역사, 그 중에서도 한국사에 해박한 세준이는 많은 역사적 사건들의 전후 관계를 잘 알고 있다. 즉, 임진왜란이 병자호란보다 먼저 일어났으며, 무오사화가 기묘사화보다 먼저 일어났다는 등의 지식을 알고 있는 것이다. 세준이가 알고 있는 일부 사건들의 전후 관계들이 주어질 때, 주어진 사건들의 전후 관계도 알 수 있을까? 이를 해결하는 프로그램을 작성해 보도록 하자.  

###### [입력]
첫째 줄에 첫 줄에 사건의 개수 n(400 이하의 자연수)과 알고 있는 사건의 전후 관계의 개수 k(50,000 이하의 자연수)가 주어진다. 다음 k줄에는 전후 관계를 알고 있는 두 사건의 번호가 주어진다. 이는 앞에 있는 번호의 사건이 뒤에 있는 번호의 사건보다 먼저 일어났음을 의미한다. 물론 사건의 전후 관계가 모순인 경우는 없다. 다음에는 사건의 전후 관계를 알고 싶은 사건 쌍의 수 s(50,000 이하의 자연수)이 주어진다. 다음 s줄에는 각각 서로 다른 두 사건의 번호가 주어진다. 사건의 번호는 1보다 크거나 같고, N보다 작거나 같은 자연수이다.  

###### [출력]
s줄에 걸쳐 물음에 답한다. 각 줄에 만일 앞에 있는 번호의 사건이 먼저 일어났으면 -1, 뒤에 있는 번호의 사건이 먼저 일어났으면 1, 어떤지 모르면(유추할 수 없으면) 0을 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|5 5</br>1 2</br>1 3</br>2 3</br>3 4</br>2 4</br>3</br>1 5</br>2 4</br>3 1|0</br>-1</br>1|

###### 알고리즘 분류
> 플로이드-와샬

###### 코드 [1613_History.cpp](./1613_History.cpp)
<br>

### Gold Ⅱ
### 1007. 벡터 매칭
평면 상에 N개의 점이 찍혀있고, 그 점을 집합 P라고 하자. 집합 P의 벡터 매칭은 벡터의 집합인데, 모든 벡터는 집합 P의 한 점에서 시작해서, 또 다른 점에서 끝나는 벡터의 집합이다. 또, P에 속하는 모든 점은 한 번씩 쓰여야 한다. 벡터 매칭에 있는 벡터의 개수는 P에 있는 점의 절반이다. 평면 상의 점이 주어졌을 때, 집합 P의 벡터 매칭에 있는 벡터의 합의 길이의 최솟값을 출력하는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어있다. 테스트 케이스의 첫째 줄에 점의 개수 N이 주어진다. N은 짝수이다. 둘째 줄부터 N개의 줄에 점의 좌표가 주어진다. N은 20보다 작거나 같은 자연수이고, 좌표는 절댓값이 100,000보다 작거나 같은 정수다. 모든 점은 서로 다르다.  

###### [출력]
각 테스트 케이스마다 정답을 출력한다. 절대/상대 오차는 10^-6까지 허용한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|2</br>4</br>5 5</br>5 -5</br>-5 5</br>-5 -5</br>2</br>-100000 -100000</br>100000 100000|0.000000000000</br>282842.712474619038|

|예제 입력2|예제 출력2|
|:---|:---|
|1</br>10</br>26 -76</br>65 -83</br>78 38</br>92 22</br>-60 -42</br>-27 85</br>42 46</br>-86 98</br>92 -47</br>-41 38|13.341664064126334|

###### 코드 [1007_Vector_Matching.cpp](./1007_Vector_Matching.cpp)
<br>

### 1103. 게임
형택이는 1부터 9까지의 숫자와, 구멍이 있는 직사각형 보드에서 재밌는 게임을 한다. 일단 보드의 가장 왼쪽 위에 동전을 하나 올려놓는다. 그다음에 다음과 같이 동전을 움직인다.  
1. 동전이 있는 곳에 쓰여 있는 숫자 X를 본다.
2. 위, 아래, 왼쪽, 오른쪽 방향 중에 한가지를 고른다.
3. 동전을 위에서 고른 방향으로 X만큼 움직인다. 이때, 중간에 있는 구멍은 무시한다.

만약 동전이 구멍에 빠지거나, 보드의 바깥으로 나간다면 게임은 종료된다. 형택이는 이 재밌는 게임을 되도록이면 오래 하고 싶다. 보드의 상태가 주어졌을 때, 형택이가 최대 몇 번 동전을 움직일 수 있는지 구하는 프로그램을 작성하시오.  

###### [입력]
줄에 보드의 세로 크기 N과 가로 크기 M이 주어진다. 이 값은 모두 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 보드의 상태가 주어진다. 쓰여 있는 숫자는 1부터 9까지의 자연수 또는 H이다. 가장 왼쪽 위칸은 H가 아니다. H는 구멍이다.  

###### [출력]
첫째 줄에 문제의 정답을 출력한다. 만약 형택이가 동전을 무한번 움직일 수 있다면 -1을 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|3 7</br>3942178</br>1234567</br>9123532|5|

|예제 입력2|예제 출력2|
|:---|:---|
|1 10</br>2H3HH4HHH5|4|

|예제 입력3|예제 출력3|
|:---|:---|
|4 4</br>3994</br>9999</br>9999</br>2924|-1|

|예제 입력4|예제 출력4|
|:---|:---|
|||

|예제 입력5|예제 출력5|
|:---|:---|
|1 1</br>9|1|

|예제 입력6|예제 출력6|
|:---|:---|
|3 7</br>2H9HH11</br>HHHHH11</br>9HHHH11|2|

###### 알고리즘 분류
> 다이나믹 프로그래밍  
> 깊이 우선 탐색  

###### 코드 [1103_Game.cpp](./1103_Game.cpp)
<br>

### 1111. IQ Test
IQ Test의 문제 중에는 공통된 패턴을 찾는 문제가 있다. 수열이 주어졌을 때, 다음 수를 찾는 문제이다. 예를 들어, 1, 2, 3, 4, 5가 주어졌다. 다음 수는 무엇인가? 당연히 답은 6이다. 약간 더 어려운 문제를 보면, 3, 6, 12, 24, 48이 주어졌을 때, 다음 수는 무엇인가? 역시 답은 96이다. 이제 제일 어려운 문제를 보자. 1, 4, 13, 40이 주어졌을 때, 다음 수는 무엇일까? 답은 121이다. 그 이유는 항상 다음 수는 앞 수 X 3 + 1이기 때문이다. 은진이는 위의 3문제를 모두 풀지 못했으므로, 자동으로 풀어주는 프로그램을 작성하기로 했다. 항상 모든 답은 구하는 규칙은 앞 수 X a + b이다. 그리고, a와 b는 정수이다. 수 N개가 주어졌을 때, 규칙에 맞는 다음 수를 구하는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 N개의 수가 주어진다. 이 수는 모두 절댓값이 100보다 작거나 같은 정수이다.  

###### [출력]
다음 수를 출력한다. 만약 다음 수가 여러 개일 경우에는 A를 출력하고, 다음 수를 구할 수 없는 경우에는 B를 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|4</br>1 4 13 40|121|

|예제 입력2|예제 출력2|
|:---|:---|
|5</br>1 2 3 4 5|6|

|예제 입력3|예제 출력3|
|:---|:---|
|5</br>3 6 12 24 48|96|

|예제 입력4|예제 출력4|
|:---|:---|
|1</br>0|A|

|예제 입력5|예제 출력5|
|:---|:---|
|2</br>-1 2|A|

|예제 입력6|예제 출력6|
|:---|:---|
|2</br>57 57|57|

|예제 입력7|예제 출력7|
|:---|:---|
|4</br>16 -8 4 -2|B|

|예제 입력8|예제 출력8|
|:---|:---|
|5</br>6 5 4 3 1|B|

|예제 입력9|예제 출력9|
|:---|:---|
|4</br>-12 12 -36 60|-132|

###### 알고리즘 분류
> 브루트포스 알고리즘  

###### 코드 [1111_IQ_Test.cpp](./1111_IQ_Test.cpp)
<br>

### 1202. 보석 도둑
세계적인 도둑 상덕이는 보석점을 털기로 결심했다. 상덕이가 털 보석점에는 보석이 총 N개 있다. 각 보석은 무게 Mi와 가격 Vi를 가지고 있다. 상덕이는 가방을 K개 가지고 있고, 각 가방에 담을 수 있는 최대 무게는 Ci이다. 가방에는 최대 한 개의 보석만 넣을 수 있다. 상덕이가 훔칠 수 있는 보석의 최대 가격을 구하는 프로그램을 작성하시오.  

###### [입력]
첫째 줄에 N과 K가 주어진다. (1 ≤ N, K ≤ 300,000)  
다음 N개 줄에는 각 보석의 정보 Mi와 Vi가 주어진다. (0 ≤ Mi, Vi ≤ 1,000,000)  
다음 K개 줄에는 가방에 담을 수 있는 최대 무게 Ci가 주어진다. (1 ≤ Ci ≤ 100,000,000)  
모든 숫자는 양의 정수이다.  

###### [출력]
첫째 줄에 상덕이가 훔칠 수 있는 보석 가격의 합의 최댓값을 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|2 1</br>5 10</br>100 100</br>11|10|

|예제 입력2|예제 출력2|
|:---|:---|
|3 2</br>1 65</br>5 23</br>2 99</br>10</br>2|164|

###### 알고리즘 분류
> 그리디 알고리즘  
> 우선순위 큐

###### 코드 [1202_Jewel_Thief.cpp](./1202_Jewel_Thief.cpp)
<br>

### 1300. K번째 수
세준이는 크기가 N×N인 배열 A를 만들었다. 배열에 들어있는 수 A[i][j] = i×j 이다. 이 수를 일차원 배열 B에 넣으면 B의 크기는 N×N이 된다. B를 오름차순 정렬했을 때, B[k]를 구해보자. 배열 A와 B의 인덱스는 1부터 시작한다.  

###### [입력]
첫째 줄에 배열의 크기 N이 주어진다. N은 10^5보다 작거나 같은 자연수이다. 둘째 줄에 k가 주어진다. k는 min(10^9, N^2)보다 작거나 같은 자연수이다.  

###### [출력]
B[k]를 출력한다.  

###### [예제 입력/출력]
|예제 입력1|예제 출력1|
|:---|:---|
|3</br>7|6|

###### 알고리즘 분류
> 이분 탐색  

###### 코드 [1300_Kth_number.cpp](./1300_Kth_number.cpp)

------
<br>

##### 문제출처 및 이용 사이트
> 백준 [Baekjoon](https://www.acmicpc.net)  

##### 사용 프로그램
> Visual Studio 2019  
